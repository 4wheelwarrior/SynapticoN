<html>
<head>
	<style>
		#thebody{
			
			width: 1024px ;
			height: 768px ;
			background: url('img/bg-blu.png') ;
			background-position: center ;
		}

		#sg-container{
			position: absolute ;
			width: 1024px ;
			height: 768px ;
			z-index: 100 ;
			-webkit-transition: opacity 5s;
			-webkit-transform: translateZ(0) ;
		}
	</style>
	<script language="javascript" src="tween.js"></script>
	<script language="javascript">

		var _cnv ;
		var _ctx ;

		var C_SEGS = 6 ;

		// "Draw Queue" ... no blizzards here
		// Each entry is a set of parameters for drawCell() ;
		// [[cx, cy, r, o], [cx, cy, r, o], ... ]
		var _DQ = [] ;
		var _DQR = [] ;
		var _iDQ = 0 ;

		var C_DA = 2.39982772 ;
		var C_PHI = ( 1 + Math.sqrt(5) ) / 2 ;

		var C_CRAD_ORG = 10 ; // +/- % variance in SG pattern

		// TODO: make random factor increase with each draw
		// ... like a 2nd derivative or something
		var _CRAD_ORG = 0 ;
		var C_CRAD_INC = 10 ;
		var _CRAD_CLK = 0 ;

		// 0 = clockwise, 1 = ccw. Default draw order is clockwise (0)
		var _dir = 0 ;

		var _IDF ;

		function main()
		{
			_cnv = document.getElementById('sg-container') ;
			_ctx = _cnv.getContext('2d') ;

			document.getElementById('thebody').addEventListener('click',doReload,false) ;

			doSGCycle() ;
			window.setInterval('doSGCycle()',10000) ;
			//window.setInterval('drawRandom()',10) ;

			//window.setTimeout(function(){window.setInterval('drawRandom()',20)},2000) ;
			//window.setTimeout('doFadeOut()',5000) ;
		}

		function doSGCycle()
		{
			_DQ = [] ;

			var rBase = randomInt(10,30) ;
			var aOff = 2 * Math.PI / randomInt(1,7) ;
			//var aOff = 0 ;

			var cx = 512 / 2 ;
			var cy = 384 / 2 ;

			// Simple randomization here, for now ...
			// Gives an idea of what different variations look like
			C_CRAD_ORG = randomInt(0,20) ;

			clearSGCanvas() ;
			_cnv.style.opacity = 1.0 ;

			for(var i = 0; i < 3; i++)
			{
				// No point in drawing the entire thing if ya can't see it!!
				if(i < 4)
					drawFol(cx, cy, rBase * Math.pow(C_PHI,(i + 1)), (aOff + C_DA * (i + 1))) ;
				else
					drawSol(cx, cy, rBase * Math.pow(C_PHI,(i + 1)), (aOff + C_DA * (i + 1))) ;
			}

			//console.log('Starting draw sequence, DQ size is '+_DQ.length) ;
			// Start draw queue processor. Stopped when drawFaded() has no more elements
			_IDF = window.setInterval('drawFaded()',100) ;

			// Reverse direction for next cycle
			
			if(!_dir)
				_dir = 1 ;
			else
				_dir = 0 ;
		}

		function clearSGCanvas()
		{
			_ctx.clearRect(0,0,512,384) ;
		}

		function doReload()
		{
			window.location.href = 'sg-canvas.html' ;
		}

		function doFadeOut()
		{
			_cnv.style.opacity = 0 ;
		}

		function drawAnim()
		{
			if(!_DQ.length) return ;
			if(_iDQ > _DQ.length - 1) return ;

			// If we've painted enough coats, move onto the next cell in the queue...
			//if(_cnt >= 5){ _cnt = 0; _iDQ++ }

			drawCell(_DQ[_iDQ][0], _DQ[_iDQ][1], _DQ[_iDQ][2], 0.1) ;
			//_cnt++ ;
			_iDQ++ ;
		}

		var _iDF = 0 ;
		var C_DFWIN_SIZE = 12 ;

		function drawFaded()
		{
			var iMin = _iDF ;
			var iMax = iMin + C_DFWIN_SIZE ;
			var iLoc ;

			if(iMax >= _DQ.length)
			{
				// Linger briefly, then fade
				window.setTimeout('doFadeOut()',1200) ;
				window.clearInterval(_IDF) ;
				_iDF = 0 ;
				return ;
			}

			for(var i = iMin; i <= iMax; i++)
			{
				// If direction == 1 (counterclockwise), reverse draw queue
				if(_dir) iLoc = _DQ.length - i - 1 ;

				// Otherwise, draw normally
				if(!_dir) iLoc = i ;

				//console.log('Painting faded at idx '+iLoc+'/'+i+'/'+_dir) ;
				drawCell(_DQ[iLoc][0], _DQ[iLoc][1], _DQ[iLoc][2], 0.06) ;
			}

			_iDF += C_DFWIN_SIZE / 3 ;
		}

		var iDR = 0 ;
		var C_DRWIN_SIZE = 8 ;
		var rCount = 0 ;
		var C_RC_MAX = 5 ; // # of random plots to make before incrementing iDR
		function drawRandom()
		{
			var iMin = iDR  ;
			var iMax = iMin + C_DRWIN_SIZE ;

			//console.log('iMin/iMax: '+iMin+'/'+iMax)

			if(iMax >= _DQ.length) return ;

			var i = randomInt(iMin, iMax) ;

			drawCell(_DQ[i][0], _DQ[i][1], _DQ[i][2], 0.1) ;

			rCount++ ;
			if(rCount < C_RC_MAX) return ;

			rCount = 0 ;
			iDR += Math.round(C_DRWIN_SIZE / 2) ;
		}

		function drawFol(cx, cy, r, ao){
		    var a ;
		    var x ;
		    var y ;

		    drawSol(cx, cy, r, ao) ;

		    for(var i = 0; i < C_SEGS; i++){
		        a = ao + (i + 1) * (2 * Math.PI / C_SEGS) ;
		        x = Math.round(cx + 2 * r * Math.cos(a)) ;
		        y = Math.round(cy + 2 * r * Math.sin(a)) ;

		        drawSol(x, y, r, a) ;
		    }
		}

		function drawSol(cx, cy, r, ao){
		    var a ;
		    var x ;
		    var y ;

		    _DQ.push([cx, cy, r]) ;

		    for(var i = 0; i < C_SEGS; i++){
		        a = ao + (i + 1) * (2 * Math.PI / C_SEGS) ;
		        x = Math.round(cx + r * Math.cos(a)) ;
		        y = Math.round(cy + r * Math.sin(a)) ;
		        _DQ.push([x, y, r]) ;
		    }
		}

		function drawCell(cx, cy, rNom, o){
		    var cR = 255 ;
		    var cG = 255 ;
		    var cB = 255 ;

		    var r = rNom * ( randomInt((100 - C_CRAD_ORG),(100 + C_CRAD_ORG)) / 100 ) ;
		    r = Math.round(r) ;

		    var rg = _ctx.createRadialGradient(cx, cy, 10, cx, cy, r) ;

		    if(!o) o = 1.0 ;

		    rg.addColorStop(0, 		'rgba('+cR+', '+cG+', '+cB+', 0.0)') ;
		    rg.addColorStop(0.6, 	'rgba('+cR+', '+cG+', '+cB+', 0.0)') ;
		    rg.addColorStop(0.9, 	'rgba('+cR+', '+cG+', '+cB+', '+ 0.2 * o +')') ;
		    rg.addColorStop(1, 		'rgba('+cR+', '+cG+', '+cB+', '+ 0.2 * o +')') ;

		    _ctx.beginPath() ;
		    _ctx.arc(cx, cy, r, 0, 2 * Math.PI, false) ;
		    _ctx.fillStyle = rg ;
		    _ctx.fill() ;
		}

		function randomInt(min, max)
		{
		    return Math.floor(Math.random() * (max - min + 1)) + min;
		}

		// Animates a mask to clear from center out ... come back to this
		function clearCell()
		{

		}
	</script>
</head>
<body id="thebody">
	<canvas id="sg-container" width="512" height="384"></canvas>
	<script>window.setTimeout('main()',300)</script>
</body>
</html>