<html>
<head>

<title>SynapticonN</title>

<script src="phonegap.js"></script>

</head>

<body 	id="thebody">

<iframe id="build-number"
        style="position:absolute; z-index: 15000; background:white; width: 80px; height: 30px; padding: 0"
        src="build.txt"></iframe>

<!--                                  -->
<!--                 MARKUP           -->
<!--                                  -->
<!--
<img 	id="bezel-tl" 		src="img/bezel.png"					style="z-index: 5000" />
<img 	id="bezel-tr" 		src="img/bezel.png"					style="z-index: 5000" />
<img 	id="bezel-bl" 		src="img/bezel.png"					style="z-index: 5000" />
<img 	id="bezel-br" 		src="img/bezel.png"					style="z-index: 5000" />
-->

<div id="red-matte" style="z-index: 4500"></div>

<canvas id="spatter-paint" 		width="1024" 	height="768"	style="z-index: 4000"></canvas>
<canvas id="cnv-glass" 			width="1024" 	height="768"	style="z-index: 3500"></canvas>

<div 	id="revolver-cyl"						style="z-index: 3250"></div>
<div 	id="blu-glo"						    style="z-index: 3000"></div>
<div 	id="red-glo"						    style="z-index: 3000"></div>

<div id="segment-container">
	<img id="seg-colon" src="img/7seg-colon.png" style="left: 696px; top: 685px; z-index:" />
</div>

<img 	id="spatter-prim" 	src="img/spatter-prim.png" 		style="display:none" />
<img 	id="glass-particle" src="img/glass-particle.png" 	style="display:none" />

<!-- composite many spatter primitives @ random radii
	 and positions to make a unique 'spatter sprite',
	 which is then plastered all over #spatter-paint in a fanout pattern -->

<div 	id="rocker-sw"							style="z-index: 2750"></div>
<div 	id="hardware"							style="z-index: 2500; pointer-events: none"></div>

<div 	id="bubble-container" 					style="z-index: 2000"></div>
<div 	id="shard-container"					style="z-index: 1500"></div>

<div 	id="ray-container"						style="z-index: 550"></div>

<canvas id="g-cnv" 				width="512"		height="384" 	style="z-index: 550; opacity: 0"></canvas>
<canvas id="g-cnv-bg" 			width="512"		height="384" 	style="z-index: 500; opacity: 0"></canvas>

<div 	id="crt-blank"											style="z-index: 425"></div>
<canvas id="shard-sprite"		width="48" 		height="12"		style="display: none"></canvas>
<canvas id="bubble-sprite"		width="420" 	height="60"		style="display: none"></canvas>
<canvas id="gcell-sprite"		width="240"		height="240"	style="display: none"></canvas>


<!-- image data for coloured backgrounds -->
<div style="display: none">
	<img id="bg-0" src="img/bg-red.jpg" />
	<img id="bg-1" src="img/bg-org.jpg" />
	<img id="bg-2" src="img/bg-yel.jpg" />
	<img id="bg-3" src="img/bg-grn.jpg" />
	<img id="bg-4" src="img/bg-blu.jpg" />
	<img id="bg-5" src="img/bg-ind.jpg" />
	<img id="bg-6" src="img/bg-vio.jpg" />
</div>

<a style="position: absolute; z-index: 2000" href="game.html">RELOAD</a>
<a style="position: absolute; z-index: 2000; left: 100px" href="javascript:doFireworks()">RENDER</a>
<a style="position: absolute; z-index: 2000; left: 200px" href="spatter.html">SPATTER</a>

<a style="position: absolute; z-index: 2000; left: 300px" href="gtrace.html">GTRACE</a>

<div 	id="hmt" style="display: none"></div>

<audio id="snd-sprite" preload="auto">
	<source src="snd/sound-sprite-proto.wav">
</audio>

<!--                                  -->
<!--                 JAVASCRIPT       -->
<!--                                  -->
<script>

var C_TAPEVENT_DN	= 'touchstart' ;
var C_TAPEVENT_UP	= 'touchend' ;

var C_DISAUDIO		= false ;

var C_SCRWID		= 1024 ;
var C_SCRHGT		= 768 ;

var C_BUBRAD 		= 30 ;		// Bubble radius on sprite (native canvas coords)
var C_BUB_CRAD 		= 5 ;		// Bubble corner radius (canvas coords)
var C_BUB_R1		= 50 ;		// Inner radius defining bubble propagation start region
var C_BUB_R2		= 100 ;		// Outer radius of same

var C_BUB_R3		= 250 ;		// Inner radius defining bubble propagation end region
var C_BUB_R4		= 350 ;		// Outer radius of same

var C_BUBOPAC_INI	= 0.02 ;	// Initial bubble opacity (when it first appears)
var C_BUBOPAC_MIN	= 0.05 ;	// Min opacity that it fades into
var C_BUBOPAC_MAX	= 0.10 ;	// Max opacity " " "

var C_PBOPAC		= 0.5 ;		// 'Pre-Burst' opacity

var C_BUB_SPINT		= 1000 ;	// Interval (ms) on which spawnBubble() is called
var C_BUB_SPROB		= 20 ;		// % probability that a bubble will spawn

var C_GCELL_RAD		= 120 ;		// G sprite cell radius (canvas coords)

// Native width/height of Geom. Canvas
var C_GCNV_W 		= 512 ;
var C_GCNV_H 		= 384 ;

// Radius/Opacity of GCell sprite
var C_GSPR_R 		= 120 ;
var C_GSPR_O 		= 0.07 ;

// Interval on which drawFaded is called
var C_GDF_INT 		= 10 ;

// Number of points around circle (inherent to geometry pattern)
// Probably won't change ....
var C_GSEGS 		= 6 ;
var C_DA 			= 2.39982772 ;
var C_PHI 			= ( 1 + Math.sqrt(5) ) / 2 ;

// Draw window size
// Works like this:
// Center iDF in draw window (called "i" here for short)
// 
//  |--------i-------|
// [00, 01, 02, 03, 04, 05, 06, 07]
//
//
// Paint all cells from beginning to end of draw window
//
//  |-------> increment i by C_DFINC
//          |--------i-------|
// [00, 01, 02, 03, 04, 05, 06, 07]
//
// Paint all cells again ... rinse and repeat
// 
// NOTE: Cell opacity (C_GSPR_O) needs to be tweaked
// When changing these values because of more/less layers painted
// Eg. C_DFWIN_SIZE halves, C_GSPR_O doubles (roughly)
var C_DFWIN_SIZE 	= 8 ;
var C_DFINC 		= 2 ;

// "organic" factor range for painting geom. cells
var C_GORG_MIN 		= 5 ;
var C_GORG_MAX 		= 25 ;

// ms Delay before fading out geom. canvas after drawing
var C_GFDELAY 		= 4400 ;

// Interval on which new geom. cycles are spawned
// (includes allowance for draw time, fadeout time, and blank space)
var C_GCYC_INT 		= 10000 ;

var C_SEGPOS = [[12,7,1], [6,0,0], [0,7,1], [6,14,0], [19,14,0], [23,7,1], [19,0,0]] ;
var C_SEGTBL = [
	[0,1,1,1,1,1,1],
	[0,0,0,1,1,0,0],
	[1,0,1,1,0,1,1],
	[1,0,1,1,1,1,0],
	[1,1,0,1,1,0,0],
	[1,1,1,0,1,1,0],
	[1,1,0,0,1,1,1],
	[0,0,1,1,1,0,0],
	[1,1,1,1,1,1,1],
	[1,1,1,1,1,0,0]
] ;

var _T = 420 ; 	// Time, expressed in seconds ...
var _S = 0 ;	// Score (++ every time 5 rounds collected)

// "Geometry Draw Queue"
// Contains center points, radii for geometry cells
// Ordered in the correct sequence for drawing
var _GDQ 			= [] ;

// Actual organic factor
// Randomized at beginning of geom cycle,
// Stays the same until next cycle
var _gOrg			= 0 ;

// 0 = clockwise, 1 = ccw. Default draw order is clockwise (0)
var _gDir 			= 0 ;

// Tracks 'center point' of drawing window
// Starts at half DFWIN_SIZE
var _iDF 			= C_DFWIN_SIZE / 2 ;

// Index within drawing window ... runs from 0 to DFWIN_SIZE
// Resets once DFWIN_SIZE is reached, then _iDF is incremented
var _iDFLoc 		= _iDF - C_DFWIN_SIZE / 2 ;

// Interval for geometry drawing routine
// Gets set and cleared dynamically
var _IDG ;

// Interval for clock timer
var _ITMR ;

// Interval for shard reg update
var _IUSR ;

var C_SHDRAD		= 6 ;		// Shard sprite radius  (canvas coords)

// X coordinates defining clipping regions for shard sprite.
// Can't quite calculate this precisely from C_SHARDRAD alone.
var C_SS_IDX		= [0, 9, 21, 33, 46] ;
var C_BS_IDX		= [0, 46, 106, 165, 226, 286, 345, 404] ;

var C_SDIST_ORG		= 30 ; 		// Shard distribution "organic" factor (+/- this many degrees)
var C_BLSTRAD_ORG	= 30 ; 		// Shard "blast radius" organic factor (percentage of nominal radius)
var C_SVELOC		= 35 ;		// Shard velocity (higher = faster)
var C_SHARDPAD 		= 30 ;		// Padding beyond rNom on shard canvas (should allow for max variance)

var _cnvSS ;					// Canvas / Context for shard sprite
var _ctxSS ;

var _cnvBS ;					// Canvas/Context for bubble sprite
var _ctxBS ;

var _cnvGS ;					// Canvas/Context for G sprite
var _ctxGS ;

var _cnvG ;						// Canvas/Context for G foreground
var _ctxG ;

var _cnvGB ;					// Canvas/Context for G background
var _ctxGB ;

var _elRC ; 					// "Ray" container for lightning effects

var _SHARDREG 		= [] ;

var _elSC ;						// Container <div>'s for shards, bubbles
var _elBC ;

var _HIT 			= 0 ;
var _MIS 			= 0 ;
var _TOT 			= 0 ;

var C_WCYL			= 140 ;		// Width/Height of revolver cylinder (pixels)
var C_RCBR			= 29 ;		// Radius from center to chambers
var C_WBUL			= 40 ;		// Width/Height of bullets (pixels)
var C_CCNT			= 3 ;		// Chamber count (used to calculate angle increments)
var C_LDEL			= 750 ;		// Delay before displaying bullet (allow cyl to rotate)
var _ICYL			= 0 ;		// Current rotation index of cylinder
var _HMQ			= [] ;		// Hit/Miss queue
var _HMQLAST		= '' ;		// Last entry processed from HMQ
var _elCyl ;
var _BULLETS		= [] ;		// Bullet elements

var _bgIdx 			= 0 ;		// Background image we're currently on
var _INBG ;

var _IGCY ;						// Geometry cycle interval

// Starting times of each audio loop
// They're all the same length
var C_LOOP_DICT 	= [0,3,6,9,12,15,18] ;

// Start times and durations of all other sound effects
// Used by playSfx() function to cue and then pause after a delay
// In order, these are: 0:burst, 1:gun cock, 2:gun fire, 3:life up, 4:life down, 5:game over
var C_SFX_DICT		= [[21,1800],[23,1200],[25,2200],[28,1200],[30,1200],[32,7000]] ;

var _AUD_TIMEOUT ;
var _AUDIO ; 					// Reference to sound sprite
var _ILPP ;
var _IBSP ;

var _PAUSEGDQ = false ;

var _imgSP ; // spatter particle
var _imgGP ; // glass particle

var _cnvSP ; // spatter canvas/context
var _ctxSP ;

var _DREG = [] ; // blood drips
var _GPCL = [] ; // glass particles

// Counts calls to updateDREG
// Used to decrement spatter size every n'th cycle
var _IDREG = 0 ;

var _IDRIP ; // drip registry
var _IGPR ; // glass particle registry

var _elBody ;

var _elBGlo ;
var _elRGlo ;

var _elRS ; // rocker switch

function main()
{
	_cnvSS 		= document.getElementById('shard-sprite') ;
	_ctxSS 		= _cnvSS.getContext('2d') ;

	_cnvBS 		= document.getElementById('bubble-sprite') ;
	_ctxBS 		= _cnvBS.getContext('2d') ;

	_cnvGS 		= document.getElementById('gcell-sprite') ;
	_ctxGS 		= _cnvGS.getContext('2d') ;

	_cnvG 		= document.getElementById('g-cnv') ;
	_ctxG 		= _cnvG.getContext('2d') ;

	_cnvGB 		= document.getElementById('g-cnv-bg') ;
	_ctxGB 		= _cnvGB.getContext('2d') ;

	_elSC 		= document.getElementById('shard-container') ;

	_elRC 		= document.getElementById('ray-container') ;

	_elBC 		= document.getElementById('bubble-container') ;
	_elBC.addEventListener(C_TAPEVENT_DN, doClick, false) ;

	_elCyl 		= document.getElementById('revolver-cyl') ;

	_imgSP  	= document.getElementById('spatter-prim') ;
	_cnvSP 		= document.getElementById('spatter-paint') ;
	_ctxSP 		= _cnvSP.getContext('2d') ;

	_elBody 	= document.getElementById('thebody') ;

	_imgGP 		= document.getElementById('glass-particle') ;

	_cnvGL 		= document.getElementById('cnv-glass') ;
	_ctxGL 		= _cnvGL.getContext('2d') ;

	_elBGlo 	= document.getElementById('blu-glo') ;
	_elRGlo 	= document.getElementById('red-glo') ;

	_elRS 		= document.getElementById('rocker-sw') ;
	_elRS.addEventListener(C_TAPEVENT_DN,rsTDown,false) ;
	_elRS.addEventListener(C_TAPEVENT_UP,rsTUp,false) ;

	_AUDIO  	= document.getElementById('snd-sprite') ;

	renderBubbleSprite() ;
	renderGCellSprite() ;
	renderShardSprite() ;

	initBullets() ;

	initSegments() ;

	initGCnvBG() ;
	initGCnvFG() ;

	//startup() ;
}

function initGCnvFG()
{
	// Paint background onto canvas
	var img = document.getElementById('bg-'+_bgIdx);

	_ctxG.drawImage(img, 0, 0, 256, 192, 0, 0, 512, 384) ;
}

function initGCnvBG()
{
	// Paint background onto canvas
	var img = document.getElementById('bg-'+_bgIdx);

	_ctxGB.drawImage(img, 0, 0, 256, 192, 0, 0, 512, 384) ;
}


var _RTOUT ;
function rsTDown(ev)
{
	ev.preventDefault() ;

	// If pressing to left of switch, do nothing
	if(ev.pageX < 80) return 0 ;

	_RTOUT = window.setTimeout('powerUp()',200) ;
}

function rsTUp(ev)
{
	ev.preventDefault() ;
	window.clearTimeout(_RTOUT) ;
}

function powerUp()
{
	_elRS.style.backgroundPosition = '0px 0px' ;
	_elBGlo.style.opacity = 1 ;

	for(var i = 0; i < 5; i++) setDigit(i,8) ;

	window.setTimeout(function(){
		_elCyl.style.webkitTransform = 'rotate(180deg)' ;
	},500) ;

	window.setTimeout(function(){
		_elCyl.style.webkitTransform = 'rotate(-180deg)' ;
	},1500) ;

	window.setTimeout(function(){
		_elCyl.style.webkitTransform = 'rotate(0deg)' ;
	},2500) ;

	window.setTimeout(function(){
		setDigit(0,7) ;
		setDigit(1,0) ;
		setDigit(2,0) ;

		setDigit(3, -1) ;
		setDigit(4, 0) ;
	},2000) ;

	window.setTimeout(function(){
		_cnvG.style.opacity = 1 ;
	},3000) ;

	window.setTimeout(function(){
		_cnvGB.style.diplay = 'block' ;
	},4000) ;

	window.setTimeout(function(){

		// Start the loop here too, because it'll sound sexy ...
		// And audio needs to be triggered by a user event
		// Because of some bullshit data plan babysitting routine :p
		playAudio() ;
		_AUD_TIMEOUT = window.setTimeout('pauseAudio()',2200) ; // Stop after 2.2s

		_ILPP = window.setInterval('doAudioLoop()',4000) ;

		doGCycle() ;
		_IGCY = window.setInterval('doGCycle()',C_GCYC_INT) ;

		// Fire up other tickers
		_IUSR = window.setInterval('updateShardReg()', 200) ;
		window.setInterval('shardRegGC()', 2000) ;
		_IBSP = window.setInterval('spawnBubble()', C_BUB_SPINT) ;
		window.setInterval('processHMQ()', 200) ;

		_ITMR = window.setInterval('timeTick()',1000) ;
	},5000) ;
}

function nextBG()
{
	// If we're on the last background already, we're done ... halt the game
	if(_bgIdx == 6)
	{
		halt() ;
		return ;
	}
    
    _bgIdx++ ;

    // Re-initialize background canvas to new colour
    initGCnvBG() ;
}

function halt()
{
	alert('Done!') ;
	window.clearInterval(_INBG) ;
}

function updateHMT()
{
	document.getElementById('hmt').innerHTML = 'HIT: '+_HIT+' | MISS: '+_MIS+' | TOT: '+_TOT ;
}

function doClick(ev)
{
	ev.preventDefault() ;

	var t = ev.target ;

	if(t.className != 'bubble-canvas')
	{
		_HMQ.push('M') ;
		return 0 ;
	}

	// Trigger burst sound
	playSfx(0) ;

	t.style.webkitTransition = 'none' ;
	t.style.opacity = 0.5 ;
	//window.setTimeout(function(){t.style.opacity = 0},100) ;
	//window.setTimeout(function(){t.style.opacity = 0.3},300) ;

	var rect = t.getBoundingClientRect();
	//console.log(rect.top, rect.right, rect.bottom, rect.left);

	var cx = Math.floor(rect.left + (rect.right - rect.left) / 2 ) ;
	var cy = Math.floor(rect.top + (rect.bottom - rect.top) / 2 ) ;
	//console.log('Calculated center point: '+cx+', '+cy) ;

	var p = randomInt(3,7) ;	// particle count
	var i = randomInt(0,6) ;	// sprite selection

	// Trigger explosion
	spawnShardCanvas(cx, cy, 200, p) ;

	// Eliminate bubble canvas, mark it as "exploded"
	// (which gets picked up by auto-explode timeout set on spawnBubble())
	window.setTimeout(function(){
		t.rel = 'exp' ;
		t.parentNode.removeChild(t) ;
	},50) ;

	// Load a 'rear' bullet
	_HMQ.push('H') ;

	_HIT++ ;
	updateHMT() ;
}

function doCopy()
{
	var x1, x2, w ;

	// Copy some shards
	for(var i = 0; i < 4; i++)
	{
		x1 = C_SS_IDX[i] ;
		x2 = C_SS_IDX[i + 1] ;

		w = x2 - x1 ;

		_ctxTC.drawImage(_cnvSS, x1, 0, w, C_SHDRAD * 2, randomInt(50,100), randomInt(50,100), w, 12) ;
	}

	for(i = 0; i < 6; i++)
	{

		// Copy a bubble
		x1 = C_BS_IDX[i] ;
		x2 = C_BS_IDX[i + 1] ;

		w = x2 - x1 ;

		_ctxTC.drawImage(_cnvBS, x1, 0, w, C_BUBRAD * 2, randomInt(0,150), randomInt(0,150), w, C_BUBRAD * 2) ;
	}
}

function renderShardSprite()
{
	// Centerline of shard being drawn
	// Starts at half of shard width
	var cX = C_SHDRAD / 2 ;
	var cY = C_SHDRAD ;

	// Render polygons
	for(var vCount = 3; vCount <= 6; vCount++)
	{
		drawPoly(_ctxSS, cX, cY, C_SHDRAD, vCount, 0) ;
		cX += 2 * C_SHDRAD ;
	}
}

function renderGCellSprite()
{
    var cR 	= 255 ;
    var cG 	= 255 ;
    var cB 	= 255 ;

    var o 	= C_GSPR_O ;

    // Creating separate vars for readability
    var cx  = C_GSPR_R ;
    var cy 	= C_GSPR_R ;
    var r 	= C_GSPR_R ;

    var rg 	= _ctxGS.createRadialGradient(cx, cy, 10, cx, cy, r) ;

    rg.addColorStop(0, 		'rgba('+cR+', '+cG+', '+cB+', 0.0)') ;
    rg.addColorStop(0.6, 	'rgba('+cR+', '+cG+', '+cB+', 0.0)') ;
    rg.addColorStop(0.9, 	'rgba('+cR+', '+cG+', '+cB+', '+ 0.2 * o +')') ;
    rg.addColorStop(1, 		'rgba('+cR+', '+cG+', '+cB+', '+ 0.2 * o +')') ;

    _ctxGS.beginPath() ;
    _ctxGS.arc(cx, cy, r, 0, 2 * Math.PI, false) ;
    _ctxGS.fillStyle = rg ;
    _ctxGS.fill() ;
}

function renderBubbleSprite()
{
	// Centerline of bubble being drawn
	// Starts at half of bubble width
	var cX = C_BUBRAD / 2 ;
	var cY = C_BUBRAD ;

	// Render polygon bubbles
	for(var vCount = 3; vCount <= 8; vCount++)
	{
		drawRoundedPoly(_ctxBS, cX, cY, C_BUBRAD, C_BUB_CRAD, vCount, 0) ;
		cX += 2 * C_BUBRAD ;
	}

	// And now, a circular bubble... fake it for now :)
	drawRoundedPoly(_ctxBS, cX, cY, C_BUBRAD, C_BUB_CRAD, 16, 0) ;
}




/***************************************************
*
*					 Geometry Routines
*
****************************************************/


function clearGCanvas()
{
	_ctxG.clearRect(0,0,C_GCNV_W,C_GCNV_H) ;
}

function doGCycle()
{
	// Clear draw queue, re-randomize oragnic factor
	_GDQ = [] ;
	_GORG = randomInt(C_GORG_MIN, C_GORG_MAX) ;

	var rBase = randomInt(10,30) ;
	var aOff = 2 * Math.PI / randomInt(1,7) ;

	var cx = C_GCNV_W / 2 ;
	var cy = C_GCNV_H / 2 ;

	//clearGCanvas() ;

	// Paint background onto canvas
	//var img = document.getElementById('bg-'+_bgIdx);

	//_ctxG.drawImage(img, 0, 0, 256, 192, 0, 0, 1024, 768) ;
	//_ctxGB.drawImage(img, 0, 0, 256, 192, 0, 0, 1024, 768) ;

	// Re-initialize foreground canvas to current colour
	initGCnvFG() ;
	_cnvG.style.opacity = 1.0 ;

	// Calculate cell coordinates
	for(var i = 0; i < 3; i++)
	{
		calcFol(cx, cy, rBase * Math.pow(C_PHI,(i + 1)), (aOff + C_DA * (i + 1))) ;
	}

	// One more iteration ... (i will already be incremented from for() loop)
	calcSol(cx, cy, rBase * Math.pow(C_PHI,(i + 1)), (aOff + C_DA * (i + 1))) ;

	// If direction is reversed (_gDir = 1), reverse array
	if(_gDir) _GDQ.reverse() ;

	//console.log('Starting draw sequence, DQ size is '+_GDQ.length) ;
	// Start draw queue processor. Stopped when drawFaded() has no more elements
	_IDG = window.setInterval('drawFaded()',C_GDF_INT) ;

	// Flip draw direction for next cycle
	if(!_gDir) _gDir = 1 ;
	else _gDir = 0 ;
}

function drawFaded()
{
	if(_PAUSEGDQ) return false ;

	// If we've reached the end of the draw queue,
	// Stop drawing, set fade out timer, reset for next cycle
	if(_iDFLoc >= _GDQ.length)
	{
		// Linger briefly, then fade
		window.setTimeout(function(){_cnvG.style.opacity = 0}, C_GFDELAY) ;
		window.clearInterval(_IDG) ;

		// Reset draw pointers
		_iDF = C_DFWIN_SIZE / 2 ;
		_iDFLoc = _iDF - C_DFWIN_SIZE / 2 ;

		return ;
	}

	// If we've reached the end of the draw window...
	// Advance _iDF (center point) to next position
	// And position iDFLoc to the beginning of the new draw window
	if(_iDFLoc > _iDF + C_DFWIN_SIZE / 2)
	{
		_iDF += C_DFINC ;
		_iDFLoc = _iDF - C_DFWIN_SIZE  / 2 ;

		return ;
	}

	// Paint the cell
	//console.log('Painting cell at _iDFLoc: '+_iDFLoc) ;
	drawGCell(_GDQ[_iDFLoc][0], _GDQ[_iDFLoc][1], _GDQ[_iDFLoc][2]) ;

	_iDFLoc++ ;
}

function drawGCell(cx, cy, rNom)
{
    // Apply organic factor to nominal radius
    var r = rNom * ( randomInt((100 - _GORG),(100 + _GORG)) / 100 ) ;
    r = Math.round(r) ;

    //console.log('Drawing with cx/cy/rNom/r '+cx+'/'+cy+'/'+rNom+' / '+r) ;

    // Calculate x, y of top left corner relative to center
    // Where cell will be placed
    var x = cx - r ;
    var y = cy - r ;

    // Calculate width/height of clipping area on sprite canvas
    var wCopy = C_GSPR_R * 2 ;

    _ctxG.drawImage(_cnvGS, 0, 0, wCopy, wCopy, x, y, r * 2, r * 2) ;
}

function calcFol(cx, cy, r, ao){
    var a ;
    var x ;
    var y ;

    calcSol(cx, cy, r, ao) ;

    for(var i = 0; i < C_GSEGS; i++){
        a = ao + (i + 1) * (2 * Math.PI / C_GSEGS) ;

        x = Math.round(cx + 2 * r * Math.cos(a)) ;
        y = Math.round(cy + 2 * r * Math.sin(a)) ;

        calcSol(x, y, r, a) ;
    }
}

function calcSol(cx, cy, rNom, ao){
    var a ;
    var x ;
    var y ;

    // Round off radius before pushing into draw queue
    _GDQ.push([cx, cy, Math.round(rNom)]) ;

    for(var i = 0; i < C_GSEGS; i++){
        a = ao + (i + 1) * (2 * Math.PI / C_GSEGS) ;
        x = Math.round(cx + rNom * Math.cos(a)) ;
        y = Math.round(cy + rNom * Math.sin(a)) ;
        _GDQ.push([x, y, Math.round(rNom)]) ;
    }
}



/***************************************************
*
*					 Bubble Routines
*
****************************************************/

// Spawns a bubble centered at screen coordinates x, y
// With radius r, final opacity o, and shape 'i' (corresponds to bubble sprite index)
function spawnBubble()
{
	var t = randomInt(0,100) ;
	if(t > C_BUB_SPROB) return 0 ;

	// Clipping region on sprite
	var x1, x2, w ;

	var cnv 	= document.createElement('canvas') ;
	var ctx 	= cnv.getContext('2d') ;

	var i 		= randomInt(0,6) ;		// bubble sprite selection

	// Calculate bubble radius
	var r 		= randomInt(50, 100) ;	// nominal radius

	// Calculate radius and angle of propagation
	var r1      = randomInt(C_BUB_R1, C_BUB_R2) ;
	var r2      = randomInt(C_BUB_R3, C_BUB_R4) ;

	// Approximate ... 2PI/1000 is virtually zero ..
	var a       = randomInt(0, (2 * Math.PI) * 100) / 100 ;
	//console.log('Spawn angle, r1, r2 '+a+', '+r1+', '+r2) ;

	// Calculate initial/final x,y position
	//var xIni	= Math.floor(C_SCRWID / 2 + r1 * Math.cos(a)) ;
	//var yIni	= Math.floor(C_SCRHGT / 2 + r1 * Math.sin(a)) ;

	//var xFin	= Math.floor(C_SCRWID / 2 + r2 * Math.cos(a)) ;
	//var yFin	= Math.floor(C_SCRHGT / 2 + r2 * Math.sin(a)) ;

	var xIni	= randomInt(100, C_SCRWID - 100) ;
	var yIni	= randomInt(100, C_SCRHGT - 100) ;

	var rot 	= randomInt(0,360) ;

	//console.log('Spawning bubble with xIni/yIni/xFin/yFin '+xIni+'/'+yIni+'/'+xFin+'/'+yFin) ;
	cnv.className 		= 'bubble-canvas' ;
	cnv.width 			= 2 * r ;
	cnv.height 			= 2 * r ;

	cnv.style.width 	= 2 * r + 'px' ;
	cnv.style.height 	= 2 * r + 'px' ;
	cnv.style.position 	= 'absolute' ;
	cnv.style.left 		= (xIni - r) + 'px' ;
	cnv.style.top 		= (yIni - r) + 'px' ;
	cnv.style.opacity 	= C_BUBOPAC_INI ;
	cnv.style.webkitTransform = 'rotate(' + rot + 'deg)' ;

	x1 = C_BS_IDX[i] ;
	x2 = C_BS_IDX[i + 1] ;

	w = x2 - x1 ;
	//console.log('Copying from coords '+x1+', '+x2+', '+w) ;
	ctx.drawImage(_cnvBS, x1, 0, w, C_BUBRAD * 2, 0, 0, 2 * r, 2 * r) ;

	_elBC.appendChild(cnv) ;

	_TOT++ ;
	updateHMT() ;

	// Re-set positions to animate....
	window.setTimeout(function(){
		cnv.style.webkitTransform = 'rotate(' + rot + 'deg) scale(1.4,1.4)' ;
		//cnv.style.left = (xFin - r) + 'px' ;
		//cnv.style.top = (yFin - r) + 'px' ;
		cnv.style.opacity = randomInt(C_BUBOPAC_MIN * 100, C_BUBOPAC_MAX * 100) / 100 ;
	},50) ;

	// Set lifecycle timer...
	window.setTimeout(function(){
		//if(!cnv){console.log('Bubble already popped'); return 0;}
		if(cnv.rel == 'exp'){console.log('Bubble already popped'); return 0;}

		// Play burst effect
		playSfx(0) ;

		cnv.style.webkitTransition = 'none' ;
		cnv.style.opacity = 0.5 ;
		//window.setTimeout(function(){cnv.style.opacity = 0},100) ;
		//window.setTimeout(function(){cnv.style.opacity = 0.3},300) ;

		spawnShardCanvas(xIni, yIni, 130, randomInt(3,7)) ;
		
		window.setTimeout(function(){
			cnv.style.display = 'none' ;
			cnv.parentNode.removeChild(cnv) ;
		},50) ;

		_HMQ.push('M') ;

		_MIS++ ;
		updateHMT() ;
	},10500) ;
}




/***************************************************
*
*					 Shard/Explosion Routines
*
****************************************************/

function spawnShardCanvas(cx, cy, rNom, p)
{
	var srTmp = [] ; // complete entry for _SHARDREG
	var shTmp = [] ; // individual entries for shards (contained in each srTmp entry)

	var elCnv ;
	var elCtx ;

	var aNom ;
	var a ;			// Angle of each shard, as its being calculated (including 'organic factor' )

	// If tween ticker isn't already in slow mode, slow it down
	// It'll be reset next time updateShardReg is called and _SHARDREG is empty ...
	//if(!_TTICK_ISSLOW) ttickSlow() ;

	elCnv = document.createElement('canvas') ;

	elCnv.width 			= 2 * ( rNom + C_SHARDPAD ) ;
	elCnv.height 			= 2 * ( rNom + C_SHARDPAD ) ;

	elCnv.style.position 	= 'absolute' ;

	elCnv.style.left 		= ( cx - rNom - C_SHARDPAD ) + 'px' ;
	elCnv.style.top 		= ( cy - rNom - C_SHARDPAD ) + 'px' ;

	elCtx = elCnv.getContext('2d') ;

	srTmp.push(elCnv) ;
	srTmp.push(elCtx) ;
	srTmp.push(0) ; // 't' value, initialize to zero ... runs up to 100, indicating 100% complete animation

	srTmp.push(cx) ;
	srTmp.push(cy) ;

	
	// Now calculate starting positions and trajectories of particles
	for(var i = 0; i < p; i++)
	{
		shTmp = [] ;

		aNom = (( 2 * Math.PI ) / p) * i ;
		
		// Apply +/- percentage according to organic factors
		a = aNom * ( randomInt((100 - C_SDIST_ORG),(100 + C_SDIST_ORG)) / 100 ) ;
		r = rNom * ( randomInt((100 - C_SDIST_ORG),(100 + C_BLSTRAD_ORG)) / 100 ) ;

		shTmp.push(a) ;
		shTmp.push(Math.floor(r)) ;
		
		srTmp.push(shTmp) ;
	}
	
	_SHARDREG.push(srTmp) ;
	_elSC.appendChild(srTmp[0]) ;
}

function updateShardReg()
{
	if(!_SHARDREG.length) return 0 ;
	//console.log(_SHARDREG) ;
	var srEnt ;
	var cnv ;
	var ctx ;
	var rCur ;
	var x, y ; // xy position of particle being redrawn (calculated from rCur, a, and cnv center)
	var t ;
	var r ;

	// Hide shards
	window.setTimeout(function(){_elSC.style.display = 'none'}, 50) ;

	// Redraw canvases
	for(var i = 0; i < _SHARDREG.length; i++)
	{
		// Loop up from array only once ...
		// Should get stored as reference to array element
		srEnt = _SHARDREG[i] ;
		cnv = srEnt[0] ;
		ctx = srEnt[1] ;

		// Clear canvas for redrawing
		//ctx.clearRect(0,0,cnv.width,cnv.height) ;
		cnv.width = cnv.width ;

		srEnt[2] = srEnt[2] + C_SVELOC ;
		t = srEnt[2] ;

		// All entries from index 5 onwards are the individual shards
		for(var j = 5; j < srEnt.length; j++)
		{
			// t (scaled to 0-1.0) * r * cos(a) ... / ... sin(a)
			x = Math.round(srEnt[0].width / 2) + ((t / 100) * srEnt[j][1] * Math.cos(srEnt[j][0])) ;
			
			// width/height are same
			y = Math.round(srEnt[0].width / 2 ) + ((t / 100) * srEnt[j][1] * Math.sin(srEnt[j][0])) ;
			
			x = Math.round(x) ;
			y = Math.round(y) ;

			// Redraw shard, with a random number of edges
			// ... morphs as it blasts outwards
			drawShard(ctx, x, y, randomInt(0,3)) ;
		}
	}

	window.setTimeout(function(){_elSC.style.display = 'block'}, 150) ;
}

// i refers indices in shard sprite 0 = 3sided, 1 = 4sided ... 3 = 6sided
// Note that x,y here refers to the top-left of the shard, not the center
function drawShard(ctx, x, y, i)
{
	var x1, x2, w ;
	//console.log('drawShard() called | x:'+x+', y:'+y+', i:'+i) ;
	//console.log(ctx) ;

	x1 = C_SS_IDX[i] ;
	x2 = C_SS_IDX[i + 1] ;

	w = x2 - x1;
 
 	// Copy pixel block from shard sprite (scale up by 2x for pixellated FX)
 	var sOrg = randomInt(70,130) / 100 ;
 	var dWid = Math.floor(w * 2 * sOrg) ;
 	var dHgt = Math.floor(C_SHDRAD * 4 * sOrg) ;

	ctx.drawImage(_cnvSS, x1, 0, w, C_SHDRAD * 2, x, y, dWid, dHgt) ;
}

function shardRegGC()
{
	var srEnt ;
	var cnv ;

	for(var i = 0; i < _SHARDREG.length; i++)
	{
		srEnt = _SHARDREG[i] ;

		cnv = srEnt[0] ;
		
		// If t has reached 100 (or passed it), remove canvas .. and _SHARDREG entry
		if(srEnt[2] >= 100)
		{
			_SHARDREG.splice(i,1) ;
			cnv.parentNode.removeChild(cnv) ;
			continue ;
		}
	}
}


/***************************************************
*
*					 Revolver Routines
*
****************************************************/

function abClick(e)
{
	console.log('Adding bullet at index '+_ICYL) ;
	if(e.pageX < 512) addBullet(1) ;
	else(addBullet()) ;
}

// Distribute bullet elements around revolver chambers
// _BULLETS array (used for turning elements on/off as bullets load/unload)
// indices 0 - 4 contain player-facing bullets, starting at TDC going CCW
// indices 5 - 9 contain game-facing bullets, starting at TDC going CW
// _ICYL tracks which cylinder we're on, using same index system ...
//    note, this means bullet DIRECTION is encoded into the index itself
function initBullets()
{
	var x, y ;
	var ang ;
	var el ;

	// Distribute player-facing bullets, counterclockwise
	for(var i = 0; i < 3; i++)
	{
		el = document.createElement('img') ;
		
		// Initialize x,y to center of cylinder
		x = Math.round(C_WCYL/2) ;
		y = x ;

		ang = Math.PI / 2 + i * 2 * Math.PI / C_CCNT ;

		x = Math.round( x + C_RCBR * Math.cos(ang) - C_WBUL / 2 ) ;
		y = Math.round( y - C_RCBR * Math.sin(ang) - C_WBUL / 2 ) ;
		
		el.src 				= 'img/bullet-front.png' ;
		el.style.position 	= 'absolute' ;
		el.style.left 		= x + 'px' ;
		el.style.top 		= y + 'px' ;
		el.style.display 	= 'none' ;
		el.id    			= 'bf' + i ;

		_elCyl.appendChild(el) ;
		_BULLETS.push(el) ;
	}

	// Distribute game-facing bullets, clockwise
	for(var i = 0; i > -3; i--)
	{
		el = document.createElement('img') ;
		
		// Initialize x,y to center of cylinder
		x = Math.round(C_WCYL/2) ;
		y = x ;

		ang = Math.PI / 2 + i * 2 * Math.PI / C_CCNT ;

		x = Math.round( x + C_RCBR * Math.cos(ang) - C_WBUL / 2 ) ;
		y = Math.round( y - C_RCBR * Math.sin(ang) - C_WBUL / 2 ) ;
		
		el.src 				= 'img/bullet-rear.png' ;
		el.style.position 	= 'absolute' ;
		el.style.left 		= x + 'px' ;
		el.style.top 		= y + 'px' ;
		el.style.display 	= 'none' ;
		el.id    			= 'br' + Math.abs(i) ;

		_elCyl.appendChild(el) ;
		_BULLETS.push(el) ;
	}
}

// Adds the next bullet in sequence, clearing cylinder as necessary
// When 
function addBullet(isGameFacing)
{
	console.log('_ICYL = '+_ICYL) ;
	// If cyl is currently loaded with player-facing bullets
	// and we're loading a game-facing bullet, clear out cylinder
	if(_ICYL < 3 && isGameFacing)
	{
		unloadCyl() ;
		_ICYL = 3 ;
	}

	// If cyl is currently loaded with game-facing bullets
	// and we're loading a player-facing bullet, clear out cylinder
	if(_ICYL > 3 && !isGameFacing)
	{
		unloadCyl() ;
		_ICYL = 0 ;
	}

	_BULLETS[_ICYL].style.display = 'block' ;

	if(isGameFacing)
		_BULLETS[_ICYL].style.webkitTransform = 'rotate('+randomInt(0,360)+'deg)' ;

	// If we just loaded the last player-facing bullet, trigger death sequence
	if(_ICYL == 2)
	{
		runDeathSequence() ;
		_ICYL = 0 ;
		return ;
	}

	// If we just loaded the last game-facing bullet, trigger fireworks sequence
	if(_ICYL == 5)
	{
		window.setTimeout(function(){doFireworks() ; unloadCyl() ;},200) ;
		_ICYL = 0 ;
		scorePlus() ;
		return ;
	}

	_ICYL++ ;
}

function unloadCyl()
{
	for(var i = 0; i < _BULLETS.length; i++)
		_BULLETS[i].style.display = 'none' ;

	// Give 'er a spin
	// _elCyl.style.webkitTransform = 'rotate(360deg)' ;
}

function processHMQ()
{
	if(!_HMQ.length) return ;

	var ent = _HMQ.shift() ;

	// Play cocking sound after a short delay
	// (to allow bubble bursting sound to finish)
	window.setTimeout('playSfx(1)',500) ;

	// addBullet() handles emptying/reloading logic
	if(ent == 'H') addBullet(1) ;
	if(ent == 'M') addBullet() ;
}


/***************************************************
*
*					 Lightning Routines
*
****************************************************/

function doFireworks()
{
	window.clearInterval(_IBSP) ;
	window.setTimeout(function(){
		_IBSP = window.setInterval('spawnBubble()', C_BUB_SPINT) ;
	},3000) ;

	_PAUSEGDQ = true ;
	window.setTimeout(function(){
		_PAUSEGDQ = false ;
	},3000) ;

	doLFX() ;
	window.setTimeout('doLFX()',500) ;
	window.setTimeout('doLFX()',1000) ;
	window.setTimeout('doLFX()',1500) ;
}

function doLFX()
{
	var iStart ;
	var iStop ;

	_cnvG.style.display = 'none' ;
	window.setTimeout(function(){_cnvG.style.display = 'block'},50) ;

	for(var i = 0; i < 5; i++)
	{
		iStart = randomInt(0,_GDQ.length - 15) ;
		iStop = iStart + randomInt(3,7) ;

		spawnBolt(iStart, iStop) ;
	}

	// Pop all the bubbles while we're at it!
	var bubs = _elBC.children ;
	var cnv ;

	var rect ;

	var cx ;
	var cy ;

	for(var i = 0; i < bubs.length; i++)
	{
		cnv = bubs[i] ;

		rect = cnv.getBoundingClientRect() ;
		cx = Math.floor(rect.left + (rect.right - rect.left) / 2 ) ;
		cy = Math.floor(rect.top + (rect.bottom - rect.top) / 2 ) ;

		spawnShardCanvas(cx, cy, 130, randomInt(3,7)) ;
		cnv.rel = 'exp' ;
		cnv.style.display = 'none' ;
		cnv.parentNode.removeChild(cnv) ;
	}
}

function spawnBolt(i1,i2)
{
	spawnRayRec(i1,i2) ;
}

// Spawns a ray from i to i + 1
function spawnRayRec(i,iStop)
{
	console.log('spawnRayRec() called with i = ' + i) ;

	spawnRay(_GDQ[i][0],_GDQ[i][1],_GDQ[i + 1][0],_GDQ[i + 1][1]) ;
	if(i >= iStop) return ;

	window.setTimeout(function(){spawnRayRec(i + 1, iStop)}, 50) ;
}

// coordinates here are relative to 512 x 384 G canvas
// Must be scaled up by 2 to get screen coords ...
function spawnRay(x1,y1,x2,y2)
{
	var cnv 	= document.createElement('canvas') ;

	// Width and Height (native coords)
	var w 		= Math.abs(x2 - x1) ;
	var h 		= Math.abs(y2 - y1) ;

	// Draw coordinates on canvas
	var dx1, dy1, dx2, dy2 ;

	cnv.width 	= w ;
	cnv.height 	= h ;
	cnv.style.width = 2 * w + 'px' ;
	cnv.style.height = 2 * h + 'px' ;
	//cnv.style.border = '2px solid white' ;
	cnv.style.opacity = 0.5 ;
	cnv.style.position = 'absolute' ;
	cnv.style.zIndex = 550 ;
	cnv.style.webkitTransition = 'opacity 0.5s' ;

	if(x2 > x1){ cnv.style.left = 2 * x1 ; dx1 = w ; dx2 = 0 }
	if(x2 < x1){ cnv.style.left = 2 * x2 ; dx1 = 0 ; dx2 = w }

	if(y2 > y1){ cnv.style.top = 2 * y1 ; dy1 = h ; dy2 = 0 }
	if(y2 < y1){ cnv.style.top = 2 * y2 ; dy1 = 0 ; dy2 = h }

	// Special cases for dead horizontal/vertical lines ...
	// allow extra room for padding
	if(w == 1)
	{
		cnv.width = 10 ;
		cnv.style.width = '20px' ;
		dx1 = 5 ;
		dx2 = 5 ;
	}

	if(h == 1)
	{
		cnv.height = 10 ;
		cnv.style.height = '20px' ;
		dy1 = 5 ;
		dy2 = 5 ;
	}

	_elRC.appendChild(cnv) ;
	window.setTimeout(function(){cnv.style.opacity = 0},20) ;

	window.setTimeout(function(){
		cnv.parentNode.removeChild(cnv) ;
	},1000) ;

	ctx = cnv.getContext('2d') ;

	ctx.strokeStyle = 'rgba(255,255,255,0.2)' ;
	ctx.lineWidth = 8 ;
	ctx.moveTo(dx1,dy1) ;
	ctx.lineTo(dx2,dy2) ;

	ctx.stroke() ;

	ctx = cnv.getContext('2d') ;

	ctx.strokeStyle = 'rgba(255,255,255,0.3)' ;
	ctx.lineWidth = 5 ;
	ctx.moveTo(dx1,dy1) ;
	ctx.lineTo(dx2,dy2) ;

	ctx.stroke() ;

	ctx = cnv.getContext('2d') ;

	ctx.strokeStyle = 'rgba(255,255,255,0.6)' ;
	ctx.lineWidth = 2 ;
	ctx.moveTo(dx1,dy1) ;
	ctx.lineTo(dx2,dy2) ;

	ctx.stroke() ;
}


/***************************************************
*
*					 7seg Routines
*
****************************************************/

function drawSegments(x,y,i)
{
	var el ;

	for(var j = 0; j < 7; j++)
	{
		//console.log('drawing segments at '+j) ;

		el = document.createElement('img') ;
		el.src = 'img/7seg.png' ;
		el.style.position = 'absolute' ;
		el.style.zIndex = 2600 ;
		el.id = 'seg-'+i+'-'+j ;

		el.style.top 	= y + C_SEGPOS[j][0] + 'px' ;
		el.style.left 	= x + C_SEGPOS[j][1] + 'px' ;

		if(C_SEGPOS[j][2] == 1) el.style.webkitTransform = 'rotate(90deg)' ;

		document.getElementById('segment-container').appendChild(el) ;
	}
}

function initSegments()
{
	// "Time" segments
	drawSegments(674,673,0) ;
	drawSegments(705,673,1) ;
	drawSegments(737,673,2) ;

	// "Score" segments
	drawSegments(899,673,3) ;
	drawSegments(933,673,4) ;

	// Turn off segments
	setDigit(0,-1) ;
	setDigit(1,-1) ;
	setDigit(2,-1) ;
	setDigit(3,-1) ;
	setDigit(4,-1) ;
}

function setDigit(iDig,val)
{
	var id ;
	var el ;

	// If value is negative, turn off segments
	if(val < 0)
	{
		for(var i = 0; i < 7; i++)
		{
			id = 'seg-' + iDig + '-' + i ;
			document.getElementById(id).style.display = 'none' ;
		}

		return ;
	}

	// Iterate over truth table for digit we're displaying
	for(var i = 0; i < C_SEGTBL[val].length; i++)
	{
		id = 'seg-' + iDig + '-' + i ;
		el = document.getElementById(id) ;

		if(!C_SEGTBL[val][i]) el.style.display = 'none' ;
		if(C_SEGTBL[val][i]) el.style.display = 'block' ;
	}
}

function setScore(s)
{
	var sOnes, sTens ;

	// Break down digits
	if(s > 9)
	{
		sOnes = s % 10 ;
		sTens = Math.floor(s / 10) ;
	}
	else
	{
		sOnes = s ;
		sTens = -1 ;
	}

	// Clear display
	setDigit(3,-1) ;
	setDigit(4,-1) ;

	// Re-draw it, after a short flicker
	setDigit(3,sTens) ;
	setDigit(4,sOnes) ;
}

function setTimer(t)
{
	var tSecOnes, tSecTens, tMins ;

	setDigit(0,-1) ;
	setDigit(1,-1) ;
	setDigit(2,-1) ;

	// Break down digits
	if(t < 60)
	{
		tMins = -1 ;
		tSecTens = Math.floor(t / 10) ;
		tSecOnes = t % 10 ;
	}
	else
	{
		tMins = Math.floor(t / 60) ;
		t -= (60 * tMins) ;
		tSecTens = Math.floor(t / 10) ;
		tSecOnes = t % 10 ;
	}

	setDigit(0,tMins) ;
	setDigit(1,tSecTens) ;
	setDigit(2,tSecOnes) ;
}

function testDigits()
{
	setDigit(1,0) ;
}

function scorePlus()
{
	_S++ ;
	setScore(_S) ;
}

function timeTick()
{
	if(_T < 0) return ;

	_T-- ;
	if((_T % 60) == 0) nextBG() ;
	setTimer(_T) ;
}


/***************************************************
*
*					 Death Sequence Routines
*
****************************************************/

function runDeathSequence()
{
	window.clearInterval(_IBSP) ;
	window.clearInterval(_IGCY) ;
	window.clearInterval(_ITMR) ;
	window.clearInterval(_IUSR) ;

	_cnvG.style.display 	= 'none' ;
	_cnvGB.style.display 	= 'none' ;
	_elSC.style.display 	= 'none' ;
	_cnvSP.style.display 	= 'block' ;
	_cnvGL.style.display 	= 'block' ;
	_elBC.style.display 	= 'none' ;
	_elSC.style.display     = 'none' ;

	_elBGlo.style.display   = 'none' ;
	_elRGlo.style.opacity   = 1 ;

	// Turn off rocker switch
	_elRS.style.backgroundPosition = 72 ;

	_IDRIP 	= window.setInterval('updateDREG()',200) ;
	_IGPR 	= window.setInterval('updateGPREG()',100) ;

	_elCyl.style.webkitTransform = 'rotate(360deg)' ;
	_elCyl.style.webkitTransition = '-webkit-transform 1s, top 4s' ;
	_elCyl.style.top = '200px' ;

	window.setTimeout(function(){
		_elCyl.style.webkitTransform = 'rotate(-360deg)' ;
		unloadCyl() ;
		deathSeq() ;

		document.getElementById('red-matte').style.display = 'block' ;
	
		window.setTimeout(function(){
			document.getElementById('red-matte').style.opacity = 0.3 ;
		},2000) ;

		window.setTimeout(function(){
			_elCyl.style.display = 'none' ;
		},3000) ;
	},3000) ;


}

// Counting number of shots ...
var _iDeath = 0 ;
function deathSeq()
{
	_iDeath++ ;
	if(_iDeath > 3) return ;
	shootHole() ;
	window.setTimeout('deathSeq()',randomInt(400,1000)) ;
}

var _GPREG = [] ; // glass particles [[cx, cy, r, a, w, h, rC], [], [] ... ]

function updateGPREG()
{
	var cx, cy, r, a, s, rC ;
	var x, y ;

	_ctxGL.clearRect(0,0,1024,768) ;

	for(var i = 0; i < _GPREG.length; i++)
	{
		cx 	= _GPREG[i][0] ;
		cy 	= _GPREG[i][1] ;
		r 	= _GPREG[i][2] ;
		a 	= _GPREG[i][3] ;
		w 	= _GPREG[i][4] ;
		h 	= _GPREG[i][5] ;
		rC 	= _GPREG[i][6] ;

		// If particle is "dead", skip it
		if(rC >= r)
		{
			_GPREG.splice(i,1) ;
			continue ;
		}

		rC += Math.floor(r / 4) ;
		if(rC > r) rC = r ;

		w-- ;
		if(w == 0) w = 0 ;

		x = cx + Math.floor(rC * Math.cos(a)) ;
		y = cy + Math.floor(rC * Math.sin(a)) ;

		drawGP(x, y, w, h) ;

		// Save updated width/height
		_GPREG[i][4] = w ;
		_GPREG[i][6] = rC ;
	}
}

function drawGP(cx, cy, w, h)
{
	_ctxGL.drawImage(_imgGP,0,0,24,24,cx,cy,w,h) ;
}


function spawnGlassExplosion(cx, cy, rNom, p)
{
	var r ;

	for(var i = 0; i < p; i++)
	{
		r = rNom * randomInt((100 - 50),(100 + 50)) / 100 ;
		r = Math.floor(r) ;

		a = randomInt(0, 2 * Math.PI * 100) / 100 ;
		s = randomInt(5,30) ;
		
		_GPREG.push([cx, cy, r, a, s, s, 0]) ;
	}
}

// Start in random quadrant
var _IQ = randomInt(0,3) ;
function shootHole()
{
	var cx, cy ;
	var x, y ;
	var qLoc ;

	// Pick random cx, cy from quadrant
	var qb = getQuadrantBounds(_IQ) ;
	cx = randomInt(qb[0], qb[1]) ;
	cy = randomInt(qb[2], qb[3]) ;

	// Trigger a glass explosion with random rNom and particle count
	spawnGlassExplosion(cx, cy, randomInt(200,300), randomInt(50,100)) ;

	// Create and append bullet hole
	var img = document.createElement('img') ;
	img.className = 'bhole' ;
	img.src = 'img/bullet-hole-' + randomInt(1,4) + '.png' ;

	img.style.position = 'absolute' ;
	img.style.webkitTransform = 'rotate(' + randomInt(0, 360) + 'deg)' ;

	// Calculate top/left position of image from cx, cy and dimensions
	console.log('Image dimensions: '+img.width+', '+img.height) ;
	x = cx - Math.floor(img.width / 2) ;
	y = cy - Math.floor(img.height / 2) ;

	img.style.left = x + 'px' ;
	img.style.top = y + 'px' ;

	window.setTimeout(function(){
		_elBody.appendChild(img) ;
	},75) ;
	
	// Copy quadrant index into local var so timeout
	// triggers on proper quadrant (otherwise it'd be incremented already ...)
	qLoc = _IQ ;

	window.setTimeout(function(){sprayBlood(qLoc)},500) ;

	_IQ++ ;

	if(_IQ > 3) _IQ = 0 ;
}

// Quadrant to spray in ... Q1 is NorthWest, goes CW from there...
var C_QPAD = 100 ;
function sprayBlood(iQ)
{
	var cx, cy ;
	var xMin, yMin, xMax, yMax ;
	var rMax ;

	var qb = getQuadrantBounds(iQ) ;

	xMin = qb[0] ;
	xMax = qb[1] ;
	yMin = qb[2] ;
	yMax = qb[3] ;

	cx = randomInt(xMin, xMax) ;
	cy = randomInt(yMin, yMax) ;

	// Inner ring
	rMax = randomInt(50,300) ;
	formSpatter(cx, cy, rMax) ;

	// Mid Ring
	rMax = randomInt(250,500) ;
	formSpatter(cx, cy, rMax) ;

	// Outer ring
	rMax = randomInt(400,800) ;
	formSpatter(cx, cy, rMax) ;
}

function getQuadrantBounds(iQ)
{
	var xMin, xMax, yMin, yMax ;

	if(iQ == 0){
		xMin = C_QPAD ;
		xMax = 512 - C_QPAD ;
		yMin = C_QPAD ;
		yMax = 384 - C_QPAD ;
	}

	if(iQ == 1){
		xMin = 512 - C_QPAD ;
		xMax = 1024 - C_QPAD ;
		yMin = C_QPAD ;
		yMax = 384 - C_QPAD ;
	}

	if(iQ == 2){
		xMin = C_QPAD; 
		xMax = 512 - C_QPAD ;
		yMin = 384 + C_QPAD ;
		yMax = 768 - C_QPAD ;
	}

	if(iQ == 3){
		xMin = 512 + C_QPAD ;
		xMax = 1024 - C_QPAD ;
		yMin = 384 + C_QPAD ;
		yMax = 768 - C_QPAD ;
	}

	return([xMin, xMax, yMin, yMax]) ;
}

// Basically calls doSpray a few times
// with different max radii to form full on splatter
function formSpatter(cx, cy, rMax)
{
	for(var i = 0; i < 5; i++)
	{
		//console.log('Running formSpatter with '+cx+', '+cy+', '+rMax) ;
		doSpray(cx, cy, rMax) ;
	}
}

// Does a single spray @ random angle
// centered at cx,cy with random radius
function doSpray(cx, cy, rMax)
{
	r = randomInt(50,rMax) ;

	a1 = randomInt(0, Math.floor(2 * Math.PI * 100)) / 100 ;
	a2 = a1 + randomInt(Math.PI * 25, Math.PI * 50) / 100 ;

	spray(cx, cy, a1, a2, r, 30) ;
}

// Do a blood spray centered at cx,cy
// fanning out between a1 and a2
// reaching out to average radius of rNom
// with 'p' particle count
var C_BPSIZE_MIN = 10 ;
var C_BPSIZE_MAX = 90 ;
var C_SPRAYR_ORG = 30 ;
var C_RDRIP 	 = 20 ; // max radius which will drip

function spray(cx, cy, a1, a2, rNom, p)
{
	var r ;
	var a ;

	var s ; // particle size

	var x, y ; // position of particle being plotted

	var a1int ;
	var a2int ;

	for(var i = 0; i < p; i++)
	{
		//if(a2 > a1) a = randomInt(Math.floor(a1 * 100), Math.floor(a2 * 100)) / 100 ;
		//if(a2 < a1) a = randomInt(Math.floor(a2 * 100), Math.floor(a1 * 100)) / 100 ;
		a1int = Math.floor(a1 * 100) ;
		a2int = Math.floor(a2 * 100) ;

		//console.log('randomizing angle between '+a1int+' and '+a2int) ;

		a = randomInt(a1int,a2int) / 100 ;

		r = rNom * ( randomInt((100 - C_SPRAYR_ORG),(100 + C_SPRAYR_ORG)) / 100 ) ;
		r = Math.floor(r) ;
		r = randomInt(0,r) ;

		s = randomInt(C_BPSIZE_MIN, C_BPSIZE_MAX) ;

		x = Math.floor(cx + r * Math.cos(a)) ;
		y = Math.floor(cy + r * Math.sin(a)) ;

		_ctxSP.drawImage(_imgSP, 0, 0, 50, 50, x, y, s, s) ;

		if(s < C_RDRIP) _DREG.push([x,y,(s - 1),(y + randomInt(50,200))]) ;
	}
}

function updateDREG()
{
	var x, y, yFin, s, sOrg ;
	var t ;
	var p = 20 ;

	for(var i = 0; i < _DREG.length; i++)
	{
		// Randomly skip a draw every so often ... makes drips fall at diff. rates
		//var t = randomInt(0,100) ;
		//if(t < p) continue ;

		x 		= _DREG[i][0] ;
		y 		= _DREG[i][1] ;
		s 		= _DREG[i][2] ;
		yFin 	= _DREG[i][3] ;

		y += 1 ;

		// Calculate organic factor
		sOrg 	= s * ( randomInt((100 - 20), (100 + 40)) / 100) ;
		sOrg 	= Math.floor(sOrg) ;

		// Every 20th cycle, move x position
		if(!(_IDREG % 30))
		{
			x += randomInt(-2,2) ;
			_DREG[i][0] = x ;
		}

		// Re-center blood drip
		x -= Math.floor(Math.abs(sOrg - s) / 2) ;

		if(y > yFin) continue ;

		// Every 20th cycle, decrease drip size
		if(!(_IDREG % 15)) s-- ;	

		// Floor out size at 3
		if(s < 3) s = 3 ;

		// Paint a drip at the new y location
		_ctxSP.drawImage(_imgSP, 0, 0, 50, 50, x, y, sOrg, sOrg) ;

		// Save new Y position into drip reg
		_DREG[i][1] = y ;
		_DREG[i][2] = s ;
	}

	_IDREG++ ;

	if(_IDREG > 10000) _IDREG = 0 ;
}

/***************************************************
*
*					 Sound Routines
*
****************************************************/

function doAudioLoop()
{
    if(C_DISAUDIO) return 0 ;

    _AUDIO.currentTime = C_LOOP_DICT[_bgIdx] ;
    if(_AUDIO.paused) _AUDIO.play() ;

    window.clearTimeout(_AUD_TIMEOUT) ;
    _AUD_TIMEOUT = window.setTimeout('pauseAudio()',2200) ; // Stop after 2.2s
}

function playAudio()
{
    if(C_DISAUDIO) return 0 ;

    _AUDIO.play() ;
}

function pauseAudio()
{
    if(C_DISAUDIO) return 0 ;

    _AUDIO.pause() ;
}

function playSfx(i)
{
	if(C_DISAUDIO) return 0 ;
	
	var startTime = C_SFX_DICT[i][0] ;
	var pauseTime = C_SFX_DICT[i][1] ;

	// Cue to start time, play if not already playing
	_AUDIO.currentTime = startTime ;
	if(_AUDIO.paused) _AUDIO.play() ;
    
    // Clear any pending pause timeouts
    window.clearTimeout(_AUD_TIMEOUT) ;

    // Set a new timeout to pause after this sound is done
    _AUD_TIMEOUT = window.setTimeout('pauseAudio()',pauseTime) ;
}




/***************************************************
*
*					 Drawing Routines (Low Level)
*
****************************************************/

function drawPoly(ctx, cX, cY, r, vCount, aOffset)
{
	var pts = getPolyPts(cX, cY, r, vCount, aOffset) ;

	//console.log('Drawing poly with pts :') ;
	//console.log(pts) ;

	ctx.beginPath() ;

	ctx.moveTo(pts[0][0], pts[0][1]) ;

	for(var i = 1; i < pts.length; i++) ctx.lineTo(pts[i][0], pts[i][1]) ;

	ctx.closePath();

	ctx.lineWidth = 2 ;
  	ctx.strokeStyle = '#FFFFFF' ;

	ctx.stroke() ;
}

function drawRoundedPoly(ctx, cX, cY, r, cRad, vCount, aOffset)
{
	var pts ;
	
	console.log('dRP vC '+vCount) ;


	// 1st coat (innermost edge)
	pts = getPolyPts(cX, cY, r - 6, vCount, aOffset) ;
	_ctxBS.lineWidth = 8 ;
	doPolyDraw(ctx, pts, cRad, 0.2) ;

	// 2nd coat
	pts = getPolyPts(cX, cY, r - 4, vCount, aOffset) ;
	doPolyDraw(ctx, pts, cRad, 0.4) ;

	// 3rd coat
	_ctxBS.lineWidth = 5 ;
	pts = getPolyPts(cX, cY, r - 2, vCount, aOffset) ;
	doPolyDraw(ctx, pts, cRad, 0.5) ;
	
	// 4th coat (outermost edge)
	_ctxBS.lineWidth = 2 ;
	pts = getPolyPts(cX, cY, r - 1, vCount, aOffset) ;
	doPolyDraw(ctx, pts, cRad, 0.8) ;
}


/***************************************************
*
*					 Helper Routines
*
****************************************************/

// Returns vertices for basic polygon shape
function getPolyPts(cX, cY, r, vCount, aOffset)
{
	var a = 0 ;
	var x = 0 ;
	var y = 0 ;

	var pts = [] ;

	for(var i = 0; i < vCount; i++)
	{
		a = aOffset + 2 * Math.PI / vCount * i ;
		x = cX + r * Math.cos(a) ;
		y = cY + r * Math.sin(a) ;

		pts.push([Math.round(x),Math.round(y)]) ;
	}

	return pts ;
}

// Lifted from http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
// Does all the work for drawRoundedPoly() far as putting pixels down
function doPolyDraw(ctx, pts, cRad, opac)
{
	if (cRad > 0) pts = getRoundedPoints(pts, cRad);

	var pt = [] ;
	
	ctx.beginPath() ;

	for(var i = 0; i < pts.length; i++)
	{
    	pt = pts[i];

    	if (i == 0) ctx.moveTo(pt[0], pt[1])
   		else ctx.lineTo(pt[0], pt[1])

   		if (cRad > 0) ctx.quadraticCurveTo(pt[2], pt[3], pt[4], pt[5]);
    }

  	ctx.closePath();

  	ctx.strokeStyle = 'rgba(255,255,255,' + opac + ')' ;
  	ctx.stroke() ;
}


// Takes an array of points from getPolyPts
// And generates points for quadratic curves
function getRoundedPoints(pts, cRad)
{
	var i1, i2, i3, p1, p2, p3 ;

	var prevPt = [] ;
	var nextPt = [] ;

    var len = pts.length ;
    var res = new Array(len) ;

  	for (i2 = 0; i2 < len; i2++)
  	{
	    i1 = i2 - 1 ;
	    i3 = i2 + 1 ;
	    
	    if (i1 < 0) 	i1 = len - 1 ;
	    if (i3 == len) 	i3 = 0 ;
	    
	    p1 = pts[i1];
	    p2 = pts[i2];
	    p3 = pts[i3];
	    
	    prevPt = getRoundedPoint( p1[0], p1[1], p2[0], p2[1], cRad, false ) ;
	    nextPt = getRoundedPoint( p2[0], p2[1], p3[0], p3[1], cRad, true ) ;
	    
	    res[i2] = [ prevPt[0], prevPt[1], p2[0], p2[1], nextPt[0], nextPt[1] ] ;
  	}

  	return res ;
}

function getRoundedPoint(x1, y1, x2, y2, cRad, first)
{
	var total 	= Math.sqrt( Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) ) ;
    var idx 	= first ? cRad / total : ( total - cRad ) / total ;
  	
  	return [ Math.round(x1 + (idx * (x2 - x1))), Math.round(y1 + (idx * (y2 - y1))) ] ;
}

function degToRad(d)
{
	return (d / 360) * 2 * Math.PI ;
}

function radToDeg(r)
{
	var d = (r / (2 * Math.PI)) * 360
	console.log('converting to degrees: '+r+', '+d) ;
	return d ;
}

function randomInt(min, max)
{
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

</script>

<!--                                  -->
<!--                 CSS              -->
<!--                                  -->
<style>

#thebody
{
	padding: 		0 ;
	border: 		0 ;
	margin: 		0 ;
	width: 			1024px ;
	height: 		768px ;
	overflow: 		hidden ;

	background:		black ;
}

#shard-container, #bubble-container, #geom-1, #geom-2
{
	position: 		absolute ;
	width: 			1024px ;
	height: 		768px ;
}

#bubble-sprite
{
	z-index: 10000 ;
	border: 2px solid red ;
	width: 840px ;
	height: 120px ;
	opacity: 0.2 ;
}

#gcell-sprite
{
	z-index: 10000 ;
	border: 2px solid green ;
	width: 240px ;
	height: 240px ;
	opacity: 1.0 ;

	top: 300px ;
}

#shard-sprite
{
	z-index: 10000 ;
	border: 2px solid yellow ;
	width: 48px ;
	height: 12px ;
	opacity: 1.0 ;

	top: 400px ;
}

#revolver-cyl
{
	position: absolute ;
	width: 140px ;
	height: 140px ;
	background: url('img/revolver-cyl.png') ;
	/* left: 447px ; */
	left: 445px ;
	top: 590px ;

	-webkit-transition-timing-function: ease-out ;
	-webkit-transition: -webkit-transform 1s ;
}

#ray-container{
	position: absolute ;
	width: 1024px ;
	height: 768px ;
}

#g-cnv{
	position: absolute ;
	/* double native canvas size for fullscreen */
	width: 1024px ;
	height: 768px ;
	-webkit-transition: opacity 5s ;
	-webkit-transform: translateZ(0) ;
}

#g-cnv-bg{
	position: absolute ;
	/* double native canvas size for fullscreen */
	width: 1024px ;
	height: 768px ;
	display: none ;
}

.bubble-canvas
{
	-webkit-transition: opacity 10s, -webkit-transform 10s ;
}

#hmt
{
	position: absolute ;
	display: block ;
	z-index: 2000 ;
	right: 20px  ;
	top: 20px ;
	width: 200px ;
	height: 30px ;
	font-size: 11px ;
	font-family: verdana, arial, helvetica, sans-serif ;
	background: white ;
	text-align: center ;
}

#bezel-tl, #bezel-tr, #bezel-bl, #bezel-br
{
	position: absolute ;
}

#bezel-tr
{
	left: 999px ;
	top: 0px ;
	-webkit-transform: rotate(90deg) ;
}

#bezel-bl
{
	left: 0px ;
	top: 743px ;
	-webkit-transform: rotate(-90deg) ;
}

#bezel-br
{
	left: 999px ;
	top: 743px ;
	-webkit-transform: rotate(180deg) ;
}

#hardware
{
	position: absolute ;
	width: 1024px ;
	height: 768px ;
	background: url('img/hardware.png') ;
}

.bhole
{
	position: absolute ;
	z-index: 4300 ;
}

img.disp-seg
{
	position: absolute ;
	z-index: 2600 ;
}

#seg-colon
{
	position: absolute ;
	z-index: 2600 ;
}

#spatter-paint, #cnv-glass
{
	position: absolute ;
	display: none ;
}

#red-matte
{
	position: absolute ;
	width: 1024px ;
	height: 768px ;
	background: url('img/red-matte.png') ;
	display: none ;
	opacity: 0.1 ;
	-webkit-transition: opacity 10s ;
}

#blu-glo
{
	position: absolute ;
	width: 136px ;
	height: 136px ;
	background: url('img/blu-glo.png') ;

	left: 445px ;
	top: 590px ;

	display: block ;

	opacity: 0.2 ;

	-webkit-transition: opacity 5s ;
}

#red-glo
{
	position: absolute ;
	width: 240px ;
	height: 240px ;
	background: url('img/red-glo.png') ;

	left: 393px ;
	top: 536px ;

	opacity: 0 ;
}

#crt-blank
{
	position: absolute ;

	background: url('img/crt-blank.jpg') ;
	width: 999px ;
	height: 655px ;

	left: 14px ;
	top: 18px ;
}

#rocker-sw
{
	position: absolute ;

	background: url('img/rocker-sprite.png') ;

	width: 99px ;
	height: 72px ;
	background-position: 0px 72px ; /* start in "off" position */

	left: 34px ;
	top: 659px ;
}

</style>
</body>

<script>window.setTimeout('main()',500)</script>
</html>