<html>
<head>

<title>SynapticonN</title>

<script src="phonegap.js"></script>

</head>

<body 	id="thebody">

<!--                                  -->
<!--                 MARKUP           -->
<!--                                  -->

<div 	id="revolver-cyl"						style="z-index: 2500"></div>
<div 	id="bubble-container" 					style="z-index: 2000"></div>
<div 	id="shard-container"					style="z-index: 1500"></div>

<canvas id="g-cnv" 				width="512"		height="384" 	style="z-index: 500"></canvas>

<canvas id="shard-sprite"		width="48" 		height="12"		style="display: none"></canvas>
<canvas id="bubble-sprite"		width="420" 	height="60"		style="display: none"></canvas>
<canvas id="gcell-sprite"		width="240"		height="240"	style="display: none"></canvas>


<!-- these layers "peel away" as colours change -->
<div id="bg-0" class="bg-layer" style="z-index: 70; background:url('img/bg-red.png')"></div>
<div id="bg-1" class="bg-layer" style="z-index: 60; background:url('img/bg-org.png')"></div>
<div id="bg-2" class="bg-layer" style="z-index: 50; background:url('img/bg-yel.png')"></div>
<div id="bg-3" class="bg-layer" style="z-index: 40; background:url('img/bg-grn.png')"></div>
<div id="bg-4" class="bg-layer" style="z-index: 30; background:url('img/bg-blu.png')"></div>
<div id="bg-5" class="bg-layer" style="z-index: 20; background:url('img/bg-ind.png')"></div>
<div id="bg-6" class="bg-layer" style="z-index: 10; background:url('img/bg-vio.png')"></div>

<a style="position: absolute; z-index: 2000" href="game.html">RELOAD</a>
<a style="position: absolute; z-index: 2000; left: 200px" href="javascript:unloadCyl()">UNLOAD</a>

<div 	id="hmt"></div>
<!--                                  -->
<!--                 JAVASCRIPT       -->
<!--                                  -->
<script>

var C_TAPEVENT		= 'touchstart' ;

var C_SCRWID		= 1024 ;
var C_SCRHGT		= 768 ;

var C_BUBRAD 		= 30 ;		// Bubble radius on sprite (native canvas coords)
var C_BUB_CRAD 		= 5 ;		// Bubble corner radius (canvas coords)
var C_BUB_R1		= 50 ;		// Inner radius defining bubble propagation start region
var C_BUB_R2		= 100 ;		// Outer radius of same

var C_BUB_R3		= 250 ;		// Inner radius defining bubble propagation end region
var C_BUB_R4		= 350 ;		// Outer radius of same

var C_BUBOPAC_INI	= 0.02 ;	// Initial bubble opacity (when it first appears)
var C_BUBOPAC_MIN	= 0.05 ;	// Min opacity that it fades into
var C_BUBOPAC_MAX	= 0.10 ;	// Max opacity " " "

var C_PBOPAC		= 0.8 ;		// 'Pre-Burst' opacity

var C_BUB_SPINT		= 1000 ;	// Interval (ms) on which spawnBubble() is called
var C_BUB_SPROB		= 20 ;		// % probability that a bubble will spawn

var C_GCELL_RAD		= 120 ;		// G sprite cell radius (canvas coords)

// Native width/height of Geom. Canvas
var C_GCNV_W 		= 512 ;
var C_GCNV_H 		= 384 ;

// Radius/Opacity of GCell sprite
var C_GSPR_R 		= 120 ;
var C_GSPR_O 		= 0.07 ;

// Interval on which drawFaded is called
var C_GDF_INT 		= 10 ;

// Number of points around circle (inherent to geometry pattern)
// Probably won't change ....
var C_GSEGS 		= 6 ;
var C_DA 			= 2.39982772 ;
var C_PHI 			= ( 1 + Math.sqrt(5) ) / 2 ;

// Draw window size
// Works like this:
// Center iDF in draw window (called "i" here for short)
// 
//  |--------i-------|
// [00, 01, 02, 03, 04, 05, 06, 07]
//
//
// Paint all cells from beginning to end of draw window
//
//  |-------> increment i by C_DFINC
//          |--------i-------|
// [00, 01, 02, 03, 04, 05, 06, 07]
//
// Paint all cells again ... rinse and repeat
// 
// NOTE: Cell opacity (C_GSPR_O) needs to be tweaked
// When changing these values because of more/less layers painted
// Eg. C_DFWIN_SIZE halves, C_GSPR_O doubles (roughly)
var C_DFWIN_SIZE 	= 8 ;
var C_DFINC 		= 2 ;

// "organic" factor range for painting geom. cells
var C_GORG_MIN 		= 5 ;
var C_GORG_MAX 		= 25 ;

// ms Delay before fading out geom. canvas after drawing
var C_GFDELAY 		= 4400 ;

// Interval on which new geom. cycles are spawned
// (includes allowance for draw time, fadeout time, and blank space)
var C_GCYC_INT 		= 20000 ;


// "Geometry Draw Queue"
// Contains center points, radii for geometry cells
// Ordered in the correct sequence for drawing
var _GDQ 			= [] ;

// Actual organic factor
// Randomized at beginning of geom cycle,
// Stays the same until next cycle
var _gOrg			= 0 ;

// 0 = clockwise, 1 = ccw. Default draw order is clockwise (0)
var _gDir 			= 0 ;

// Tracks 'center point' of drawing window
// Starts at half DFWIN_SIZE
var _iDF 			= C_DFWIN_SIZE / 2 ;

// Index within drawing window ... runs from 0 to DFWIN_SIZE
// Resets once DFWIN_SIZE is reached, then _iDF is incremented
var _iDFLoc 		= _iDF - C_DFWIN_SIZE / 2 ;

// Interval for geometry drawing routine
// Gets set and cleared dynamically
var _IDG ;


var C_SHDRAD		= 6 ;		// Shard sprite radius  (canvas coords)

// X coordinates defining clipping regions for shard sprite.
// Can't quite calculate this precisely from C_SHARDRAD alone.
var C_SS_IDX		= [0, 9, 21, 33, 46] ;
var C_BS_IDX		= [0, 46, 106, 165, 226, 286, 345, 404] ;

var C_SDIST_ORG		= 30 ; 		// Shard distribution "organic" factor (+/- this many degrees)
var C_BLSTRAD_ORG	= 30 ; 		// Shard "blast radius" organic factor (percentage of nominal radius)
var C_SVELOC		= 25 ;		// Shard velocity expressed as # of ticks to full radius
var C_SHARDPAD 		= 30 ;		// Padding beyond rNom on shard canvas (should allow for max variance)

var _cnvSS ;					// Canvas / Context for shard sprite
var _ctxSS ;

var _cnvBS ;					// Canvas/Context for bubble sprite
var _ctxBS ;

var _cnvGS ;					// Canvas/Context for G sprite
var _ctxGS ;

var _cnvG ;						// Canvas/Context for G background
var _ctxG ;

var _SHARDREG 		= [] ;

var _elSC ;						// Container <div>'s for shards, bubbles
var _elBC ;

var _HIT 			= 0 ;
var _MIS 			= 0 ;
var _TOT 			= 0 ;

var C_WCYL			= 130 ;		// Width/Height of revolver cylinder (pixels)
var C_RCBR			= 34 ;		// Radius from center to chambers
var C_WBUL			= 33 ;		// Width/Height of bullets (pixels)
var C_CCNT			= 5 ;		// Chamber count (used to calculate angle increments)
var C_LDEL			= 750 ;		// Delay before displaying bullet (allow cyl to rotate)
var _ICYL			= 0 ;		// Current rotation index of cylinder
var _HMQ			= [] ;		// Hit/Miss queue
var _HMQLAST		= '' ;		// Last entry processed from HMQ
var _elCyl ;
var _BULLETS		= [] ;		// Bullet elements

var _bgIdx 			= 0 ;		// Background image we're currently on
var _INBG ;

function main()
{
	_cnvSS 	= document.getElementById('shard-sprite') ;
	_ctxSS 	= _cnvSS.getContext('2d') ;

	_cnvBS 	= document.getElementById('bubble-sprite') ;
	_ctxBS 	= _cnvBS.getContext('2d') ;

	_cnvGS 	= document.getElementById('gcell-sprite') ;
	_ctxGS 	= _cnvGS.getContext('2d') ;

	_cnvG 	= document.getElementById('g-cnv') ;
	_ctxG 	= _cnvG.getContext('2d') ;

	_elSC 	= document.getElementById('shard-container') ;

	_elBC 	= document.getElementById('bubble-container') ;
	_elBC.addEventListener(C_TAPEVENT, doClick, false) ;

	_elCyl 	= document.getElementById('revolver-cyl') ;

	renderBubbleSprite() ;
	renderGCellSprite() ;
	renderShardSprite() ;

	initBullets() ;

	doGCycle() ;
	window.setInterval('doGCycle()',C_GCYC_INT) ;

	// Fire up other tickers
	window.setInterval('updateShardReg()', 200) ;
	window.setInterval('shardRegGC()', 2000) ;
	window.setInterval('spawnBubble()', C_BUB_SPINT) ;
	window.setInterval('processHMQ()', 100) ;

	_INBG = window.setInterval('nextBG()',60000) ;
}

function nextBG()
{
	// If we're on the last background already, we're done ... halt the game
	if(_bgIdx == 6)
	{
		halt() ;
		return ;
	}
	
	// Retrieve background element and make it disappear!
	var el = document.getElementById('bg-'+_bgIdx) ;
		
    el.style.opacity = 0 ;

    window.setTimeout(function(){
    	el.parentElement.removeChild(el) ;
    }, 5000)
    
    _bgIdx++ ;
}

function halt()
{
	alert('Done!') ;
	window.clearInterval(_INBG) ;
}

function updateHMT()
{
	document.getElementById('hmt').innerHTML = 'HIT: '+_HIT+' | MISS: '+_MIS+' | TOT: '+_TOT ;
}

function doClick(ev)
{
	var t = ev.target ;

	if(t.className != 'bubble-canvas')
	{
		_HMQ.push('M') ;
		return 0 ;
	}

	t.style.opacity = 1 ;

	var rect = t.getBoundingClientRect();
	//console.log(rect.top, rect.right, rect.bottom, rect.left);

	var cx = Math.floor(rect.left + (rect.right - rect.left) / 2 ) ;
	var cy = Math.floor(rect.top + (rect.bottom - rect.top) / 2 ) ;
	//console.log('Calculated center point: '+cx+', '+cy) ;

	var p = randomInt(3,7) ;	// particle count
	var i = randomInt(0,6) ;	// sprite selection

	// Trigger explosion
	spawnShardCanvas(cx, cy, 200, p) ;

	// Eliminate bubble canvas, mark it as "exploded"
	// (which gets picked up by auto-explode timeout set on spawnBubble())
	window.setTimeout(function(){
		t.rel = 'exp' ;
		t.parentNode.removeChild(t) ;
	},100) ;

	// Load a 'rear' bullet
	_HMQ.push('H') ;

	_HIT++ ;
	updateHMT() ;
}

function doCopy()
{
	console.log('doCopy running ...') ;
	console.log(_ctxTC) ;
	console.log(_cnvSS) ;

	var x1, x2, w ;

	// Copy some shards
	for(var i = 0; i < 4; i++)
	{
		x1 = C_SS_IDX[i] ;
		x2 = C_SS_IDX[i + 1] ;

		w = x2 - x1 ;

		_ctxTC.drawImage(_cnvSS, x1, 0, w, C_SHDRAD * 2, randomInt(50,100), randomInt(50,100), w, 12) ;
	}

	for(i = 0; i < 6; i++)
	{

		// Copy a bubble
		x1 = C_BS_IDX[i] ;
		x2 = C_BS_IDX[i + 1] ;

		w = x2 - x1 ;

		_ctxTC.drawImage(_cnvBS, x1, 0, w, C_BUBRAD * 2, randomInt(0,150), randomInt(0,150), w, C_BUBRAD * 2) ;
	}
}

function renderShardSprite()
{
	// Centerline of shard being drawn
	// Starts at half of shard width
	var cX = C_SHDRAD / 2 ;
	var cY = C_SHDRAD ;

	// Render polygons
	for(var vCount = 3; vCount <= 6; vCount++)
	{
		drawPoly(_ctxSS, cX, cY, C_SHDRAD, vCount, 0) ;
		cX += 2 * C_SHDRAD ;
	}
}

function renderGCellSprite()
{
    var cR 	= 255 ;
    var cG 	= 255 ;
    var cB 	= 255 ;

    var o 	= C_GSPR_O ;

    // Creating separate vars for readability
    var cx  = C_GSPR_R ;
    var cy 	= C_GSPR_R ;
    var r 	= C_GSPR_R ;

    var rg 	= _ctxGS.createRadialGradient(cx, cy, 10, cx, cy, r) ;

    rg.addColorStop(0, 		'rgba('+cR+', '+cG+', '+cB+', 0.0)') ;
    rg.addColorStop(0.6, 	'rgba('+cR+', '+cG+', '+cB+', 0.0)') ;
    rg.addColorStop(0.9, 	'rgba('+cR+', '+cG+', '+cB+', '+ 0.2 * o +')') ;
    rg.addColorStop(1, 		'rgba('+cR+', '+cG+', '+cB+', '+ 0.2 * o +')') ;

    _ctxGS.beginPath() ;
    _ctxGS.arc(cx, cy, r, 0, 2 * Math.PI, false) ;
    _ctxGS.fillStyle = rg ;
    _ctxGS.fill() ;
}

function renderBubbleSprite()
{
	// Centerline of bubble being drawn
	// Starts at half of bubble width
	var cX = C_BUBRAD / 2 ;
	var cY = C_BUBRAD ;

	// Render polygon bubbles
	for(var vCount = 3; vCount <= 8; vCount++)
	{
		drawRoundedPoly(_ctxBS, cX, cY, C_BUBRAD, C_BUB_CRAD, vCount, 0) ;
		cX += 2 * C_BUBRAD ;
	}

	// And now, a circular bubble... fake it for now :)
	drawRoundedPoly(_ctxBS, cX, cY, C_BUBRAD, C_BUB_CRAD, 16, 0) ;
}




/***************************************************
*
*					 Geometry Routines
*
****************************************************/


function clearGCanvas()
{
	console.log('clearing G canvas') ;
	_ctxG.clearRect(0,0,C_GCNV_W,C_GCNV_H) ;
}

function doGCycle()
{
	console.log('Starting G cycle...') ;
	// Clear draw queue, re-randomize oragnic factor
	_GDQ = [] ;
	_GORG = randomInt(C_GORG_MIN, C_GORG_MAX) ;

	console.log('GDQ length is '+_GDQ.length) ;
	var rBase = randomInt(10,30) ;
	var aOff = 2 * Math.PI / randomInt(1,7) ;

	var cx = C_GCNV_W / 2 ;
	var cy = C_GCNV_H / 2 ;

	clearGCanvas() ;
	_cnvG.style.opacity = 1.0 ;

	// Calculate cell coordinates
	for(var i = 0; i < 3; i++)
	{
		console.log('Drawing FOL at index '+i) ;
		calcFol(cx, cy, rBase * Math.pow(C_PHI,(i + 1)), (aOff + C_DA * (i + 1))) ;
	}

	// One more iteration ... (i will already be incremented from for() loop)
	console.log('Drawing SOL at index '+i) ;
	calcSol(cx, cy, rBase * Math.pow(C_PHI,(i + 1)), (aOff + C_DA * (i + 1))) ;

	// If direction is reversed (_gDir = 1), reverse array
	if(_gDir) _GDQ.reverse() ;

	//console.log('Starting draw sequence, DQ size is '+_GDQ.length) ;
	// Start draw queue processor. Stopped when drawFaded() has no more elements
	_IDG = window.setInterval('drawFaded()',C_GDF_INT) ;

	// Flip draw direction for next cycle
	if(!_gDir) _gDir = 1 ;
	else _gDir = 0 ;
}

function drawFaded()
{
	// If we've reached the end of the draw queue,
	// Stop drawing, set fade out timer, reset for next cycle
	if(_iDFLoc >= _GDQ.length)
	{
		// Linger briefly, then fade
		window.setTimeout(function(){_cnvG.style.opacity = 0}, C_GFDELAY) ;
		window.clearInterval(_IDG) ;

		// Reset draw pointers
		_iDF = C_DFWIN_SIZE / 2 ;
		_iDFLoc = _iDF - C_DFWIN_SIZE / 2 ;

		return ;
	}

	// If we've reached the end of the draw window...
	// Advance _iDF (center point) to next position
	// And position iDFLoc to the beginning of the new draw window
	if(_iDFLoc > _iDF + C_DFWIN_SIZE / 2)
	{
		_iDF += C_DFINC ;
		_iDFLoc = _iDF - C_DFWIN_SIZE  / 2 ;

		return ;
	}

	// Paint the cell
	//console.log('Painting cell at _iDFLoc: '+_iDFLoc) ;
	drawGCell(_GDQ[_iDFLoc][0], _GDQ[_iDFLoc][1], _GDQ[_iDFLoc][2]) ;

	_iDFLoc++ ;
}

function drawGCell(cx, cy, rNom)
{
    // Apply organic factor to nominal radius
    var r = rNom * ( randomInt((100 - _GORG),(100 + _GORG)) / 100 ) ;
    r = Math.round(r) ;

    //console.log('Drawing with cx/cy/rNom/r '+cx+'/'+cy+'/'+rNom+' / '+r) ;

    // Calculate x, y of top left corner relative to center
    // Where cell will be placed
    var x = cx - r ;
    var y = cy - r ;

    // Calculate width/height of clipping area on sprite canvas
    var wCopy = C_GSPR_R * 2 ;

    _ctxG.drawImage(_cnvGS, 0, 0, wCopy, wCopy, x, y, r * 2, r * 2) ;
}

function calcFol(cx, cy, r, ao){
    var a ;
    var x ;
    var y ;

    calcSol(cx, cy, r, ao) ;

    for(var i = 0; i < C_GSEGS; i++){
        a = ao + (i + 1) * (2 * Math.PI / C_GSEGS) ;

        x = Math.round(cx + 2 * r * Math.cos(a)) ;
        y = Math.round(cy + 2 * r * Math.sin(a)) ;

        calcSol(x, y, r, a) ;
    }
}

function calcSol(cx, cy, rNom, ao){
    var a ;
    var x ;
    var y ;

    // Round off radius before pushing into draw queue
    _GDQ.push([cx, cy, Math.round(rNom)]) ;

    for(var i = 0; i < C_GSEGS; i++){
        a = ao + (i + 1) * (2 * Math.PI / C_GSEGS) ;
        x = Math.round(cx + rNom * Math.cos(a)) ;
        y = Math.round(cy + rNom * Math.sin(a)) ;
        _GDQ.push([x, y, Math.round(rNom)]) ;
    }
}



/***************************************************
*
*					 Bubble Routines
*
****************************************************/

// Spawns a bubble centered at screen coordinates x, y
// With radius r, final opacity o, and shape 'i' (corresponds to bubble sprite index)
function spawnBubble()
{
	var t = randomInt(0,100) ;
	if(t > C_BUB_SPROB) return 0 ;

	// Clipping region on sprite
	var x1, x2, w ;

	var cnv 	= document.createElement('canvas') ;
	var ctx 	= cnv.getContext('2d') ;

	var i 		= randomInt(0,6) ;		// bubble sprite selection

	// Calculate bubble radius
	var r 		= randomInt(50, 100) ;	// nominal radius

	// Calculate radius and angle of propagation
	var r1      = randomInt(C_BUB_R1, C_BUB_R2) ;
	var r2      = randomInt(C_BUB_R3, C_BUB_R4) ;

	// Approximate ... 2PI/1000 is virtually zero ..
	var a       = randomInt(0, (2 * Math.PI) * 100) / 100 ;
	console.log('Spawn angle, r1, r2 '+a+', '+r1+', '+r2) ;

	// Calculate initial/final x,y position
	//var xIni	= Math.floor(C_SCRWID / 2 + r1 * Math.cos(a)) ;
	//var yIni	= Math.floor(C_SCRHGT / 2 + r1 * Math.sin(a)) ;

	//var xFin	= Math.floor(C_SCRWID / 2 + r2 * Math.cos(a)) ;
	//var yFin	= Math.floor(C_SCRHGT / 2 + r2 * Math.sin(a)) ;

	var xIni	= randomInt(100, C_SCRWID - 100) ;
	var yIni	= randomInt(100, C_SCRHGT - 100) ;

	var rot 	= randomInt(0,360) ;

	//console.log('Spawning bubble with xIni/yIni/xFin/yFin '+xIni+'/'+yIni+'/'+xFin+'/'+yFin) ;
	cnv.className 		= 'bubble-canvas' ;
	cnv.width 			= 2 * r ;
	cnv.height 			= 2 * r ;

	cnv.style.width 	= 2 * r + 'px' ;
	cnv.style.height 	= 2 * r + 'px' ;
	cnv.style.position 	= 'absolute' ;
	cnv.style.left 		= (xIni - r) + 'px' ;
	cnv.style.top 		= (yIni - r) + 'px' ;
	cnv.style.opacity 	= C_BUBOPAC_INI ;
	cnv.style.webkitTransform = 'rotate(' + rot + 'deg)' ;

	x1 = C_BS_IDX[i] ;
	x2 = C_BS_IDX[i + 1] ;

	w = x2 - x1 ;
	//console.log('Copying from coords '+x1+', '+x2+', '+w) ;
	ctx.drawImage(_cnvBS, x1, 0, w, C_BUBRAD * 2, 0, 0, 2 * r, 2 * r) ;

	_elBC.appendChild(cnv) ;

	_TOT++ ;
	updateHMT() ;

	// Re-set positions to animate....
	window.setTimeout(function(){
		cnv.style.webkitTransform = 'rotate(' + rot + 'deg) scale(1.4,1.4)' ;
		//cnv.style.left = (xFin - r) + 'px' ;
		//cnv.style.top = (yFin - r) + 'px' ;
		cnv.style.opacity = randomInt(C_BUBOPAC_MIN * 100, C_BUBOPAC_MAX * 100) / 100 ;
	},50) ;

	// Set lifecycle timer...
	window.setTimeout(function(){
		//if(!cnv){console.log('Bubble already popped'); return 0;}
		if(cnv.rel == 'exp'){console.log('Bubble already popped'); return 0;}

		cnv.style.opacity = 1.0 ;

		spawnShardCanvas(xIni, yIni, 130, randomInt(3,7)) ;
		
		cnv.style.display = 'none' ;
		cnv.parentNode.removeChild(cnv) ;

		_HMQ.push('M') ;

		_MIS++ ;
		updateHMT() ;
	},10500) ;
}




/***************************************************
*
*					 Shard/Explosion Routines
*
****************************************************/

function spawnShardCanvas(cx, cy, rNom, p)
{
	var srTmp = [] ; // complete entry for _SHARDREG
	var shTmp = [] ; // individual entries for shards (contained in each srTmp entry)

	var elCnv ;
	var elCtx ;

	var aNom ;
	var a ;			// Angle of each shard, as its being calculated (including 'organic factor' )

	// If tween ticker isn't already in slow mode, slow it down
	// It'll be reset next time updateShardReg is called and _SHARDREG is empty ...
	//if(!_TTICK_ISSLOW) ttickSlow() ;

	elCnv = document.createElement('canvas') ;

	elCnv.width 			= 2 * ( rNom + C_SHARDPAD ) ;
	elCnv.height 			= 2 * ( rNom + C_SHARDPAD ) ;

	elCnv.style.position 	= 'absolute' ;

	elCnv.style.left 		= ( cx - rNom - C_SHARDPAD ) + 'px' ;
	elCnv.style.top 		= ( cy - rNom - C_SHARDPAD ) + 'px' ;

	elCtx = elCnv.getContext('2d') ;

	srTmp.push(elCnv) ;
	srTmp.push(elCtx) ;
	srTmp.push(0) ; // 't' value, initialize to zero ... runs up to 100, indicating 100% complete animation

	srTmp.push(cx) ;
	srTmp.push(cy) ;

	
	// Now calculate starting positions and trajectories of particles
	for(var i = 0; i < p; i++)
	{
		shTmp = [] ;

		aNom = (( 2 * Math.PI ) / p) * i ;
		
		// Apply +/- percentage according to organic factors
		a = aNom * ( randomInt((100 - C_SDIST_ORG),(100 + C_SDIST_ORG)) / 100 ) ;
		r = rNom * ( randomInt((100 - C_SDIST_ORG),(100 + C_BLSTRAD_ORG)) / 100 ) ;

		shTmp.push(a) ;
		shTmp.push(Math.floor(r)) ;
		
		srTmp.push(shTmp) ;
	}
	
	_SHARDREG.push(srTmp) ;
	_elSC.appendChild(srTmp[0]) ;
}

function updateShardReg()
{
	if(!_SHARDREG.length) return 0 ;
	//console.log(_SHARDREG) ;
	var srEnt ;
	var cnv ;
	var ctx ;
	var rCur ;
	var x, y ; // xy position of particle being redrawn (calculated from rCur, a, and cnv center)
	var t ;
	var r ;

	// Hide shards
	window.setTimeout(function(){_elSC.style.display = 'none'}, 50) ;

	// Redraw canvases
	for(var i = 0; i < _SHARDREG.length; i++)
	{
		// Loop up from array only once ...
		// Should get stored as reference to array element
		srEnt = _SHARDREG[i] ;
		cnv = srEnt[0] ;
		ctx = srEnt[1] ;

		// Clear canvas for redrawing
		//ctx.clearRect(0,0,cnv.width,cnv.height) ;
		cnv.width = cnv.width ;

		srEnt[2] = srEnt[2] + C_SVELOC ;
		t = srEnt[2] ;

		// All entries from index 5 onwards are the individual shards
		for(var j = 5; j < srEnt.length; j++)
		{
			// t (scaled to 0-1.0) * r * cos(a) ... / ... sin(a)
			x = Math.round(srEnt[0].width / 2) + ((t / 100) * srEnt[j][1] * Math.cos(srEnt[j][0])) ;
			
			// width/height are same
			y = Math.round(srEnt[0].width / 2 ) + ((t / 100) * srEnt[j][1] * Math.sin(srEnt[j][0])) ;
			
			x = Math.round(x) ;
			y = Math.round(y) ;

			// Redraw shard, with a random number of edges
			// ... morphs as it blasts outwards
			drawShard(ctx, x, y, randomInt(0,3)) ;
		}
	}

	window.setTimeout(function(){_elSC.style.display = 'block'}, 150) ;
}

// i refers indices in shard sprite 0 = 3sided, 1 = 4sided ... 3 = 6sided
// Note that x,y here refers to the top-left of the shard, not the center
function drawShard(ctx, x, y, i)
{
	var x1, x2, w ;
	//console.log('drawShard() called | x:'+x+', y:'+y+', i:'+i) ;
	//console.log(ctx) ;

	x1 = C_SS_IDX[i] ;
	x2 = C_SS_IDX[i + 1] ;

	w = x2 - x1;
 
 	// Copy pixel block from shard sprite (scale up by 2x for pixellated FX)
	ctx.drawImage(_cnvSS, x1, 0, w, C_SHDRAD * 2, x, y, w * 2, C_SHDRAD * 4) ;
}

function shardRegGC()
{
	var srEnt ;
	var cnv ;

	for(var i = 0; i < _SHARDREG.length; i++)
	{
		srEnt = _SHARDREG[i] ;

		cnv = srEnt[0] ;
		
		// If t has reached 100 (or passed it), remove canvas .. and _SHARDREG entry
		if(srEnt[2] >= 100)
		{
			_SHARDREG.splice(i,1) ;
			cnv.parentNode.removeChild(cnv) ;
			continue ;
		}
	}
}


/***************************************************
*
*					 Revolver Routines
*
****************************************************/

function abClick(e)
{
	console.log('Adding bullet at index '+_ICYL) ;
	if(e.pageX < 512) addBullet(1) ;
	else(addBullet()) ;
}

// Distribute bullet images around revolver chambers
function initBullets()
{
	var x, y ;
	var ang ;
	var el ;

	for(var i = 0; i < 5; i++)
	{
		el = document.createElement('img') ;
		
		// Initialize x,y to center of cylinder
		x = Math.round(C_WCYL/2) ;
		y = x ;

		ang = Math.PI / 2 + i * 2 * Math.PI / C_CCNT ;

		x = Math.round( x + C_RCBR * Math.cos(ang) - C_WBUL / 2 ) ;
		y = Math.round( y - C_RCBR * Math.sin(ang) - C_WBUL / 2 ) ;
		
		el.src 				= 'img/bullet-blank.png' ;
		el.style.position 	= 'absolute' ;
		el.style.left 		= x + 'px' ;
		el.style.top 		= y + 'px' ;
		el.style.opacity 	= 0 ;
		el.className		= 'bullet' ;
		el.id    			= 'b' + i ;

		_elCyl.appendChild(el) ;
		_BULLETS.push(el) ;
	}
}

function addBullet(isRear)
{
	var src ;
	var ang ;
	var bIdx ;

	if(isRear) src = 'img/bullet-rear.png' ;
	else src = 'img/bullet-front.png' ;

	// Calculate rotation angle of cylinder
	ang = Math.PI / 2 + _ICYL * 2 * Math.PI / C_CCNT ;

	// OK... so _ICYL is used for calculating cylinder angle, primarily ...
	// how do we calculate the actual INDEX of the bullet to light up?

	if(_ICYL < 0) 	bIdx = _ICYL + 5 ;
	if(_ICYL == 0) 	bIdx = 0 ;
	if(_ICYL > 0) 	bIdx = _ICYL ;

	console.log('Getting index for bIdx '+bIdx) ;
	var el = _BULLETS[bIdx] ;

	// Set image source depending on front/rear facing ...
	el.src = src ;

	// Randomize rotation (organic detail for bullet rears... lettering, etc)
	el.style.webkitTransform = 'rotate(' + randomInt(0,360) + 'deg)' ;

	// Rotate cylinder into next position (re-adjust angle to "due east" origin)
	ang -= Math.PI / 2 ;
	console.log('Rotating cylinder to '+radToDeg(ang)+'deg') ;
	_elCyl.style.webkitTransform = 'rotate(' + radToDeg(ang) + 'deg)' ;

	// Fade in appropriate bullet, after short delay (allow for rotation)
	window.setTimeout(function(){
		window.setTimeout(function(){el.style.opacity = 1},50) ;
	},(_ICYL ? C_LDEL : 0)) ;

	if(isRear) _ICYL-- ;
	else _ICYL++ ;

	// TODO: detect this elsewhere ....
	if(_ICYL > (C_CCNT - 1)) window.setTimeout(function(){
		alert('DEATH TIME!') ;
		unloadCyl() ;
	},1500) ;

	if(_ICYL < (-1 * C_CCNT + 1)) window.setTimeout(function(){
		alert('FIREWORKS TIME!');
		unloadCyl() ;
	},1500) ;
}

function unloadCyl()
{
	var el ;

	for(var i = 0; i < 5; i++)
	{
		el = _BULLETS[i] ;
		el.src = 'img/bullet-blank.png' ;
		el.style.opacity = 0 ;	
	}

	_elCyl.style.webkitTransform = 'rotate(0deg)' ;
	_ICYL = 0 ;
}

function processHMQ()
{
	if(!_HMQ.length) return ;

	var ent = _HMQ.shift() ;

	if(_HMQLAST != ent) unloadCyl() ;

	if(ent == 'H'){ addBullet(1); _HMQLAST = 'H' }
	if(ent == 'M'){ addBullet(); _HMQLAST = 'M' }
}





/***************************************************
*
*					 Drawing Routines (Low Level)
*
****************************************************/

function drawPoly(ctx, cX, cY, r, vCount, aOffset)
{
	var pts = getPolyPts(cX, cY, r, vCount, aOffset) ;

	//console.log('Drawing poly with pts :') ;
	//console.log(pts) ;

	ctx.beginPath() ;

	ctx.moveTo(pts[0][0], pts[0][1]) ;

	for(var i = 1; i < pts.length; i++) ctx.lineTo(pts[i][0], pts[i][1]) ;

	ctx.closePath();

	ctx.lineWidth = 2 ;
  	ctx.strokeStyle = '#FFFFFF' ;

	ctx.stroke() ;
}

function drawRoundedPoly(ctx, cX, cY, r, cRad, vCount, aOffset)
{
	var pts ;
	
	console.log('dRP vC '+vCount) ;


	// 1st coat (innermost edge)
	pts = getPolyPts(cX, cY, r - 6, vCount, aOffset) ;
	_ctxBS.lineWidth = 8 ;
	doPolyDraw(ctx, pts, cRad, 0.2) ;

	// 2nd coat
	pts = getPolyPts(cX, cY, r - 4, vCount, aOffset) ;
	doPolyDraw(ctx, pts, cRad, 0.4) ;

	// 3rd coat
	_ctxBS.lineWidth = 5 ;
	pts = getPolyPts(cX, cY, r - 2, vCount, aOffset) ;
	doPolyDraw(ctx, pts, cRad, 0.5) ;
	
	// 4th coat (outermost edge)
	_ctxBS.lineWidth = 2 ;
	pts = getPolyPts(cX, cY, r - 1, vCount, aOffset) ;
	doPolyDraw(ctx, pts, cRad, 0.8) ;
}


/***************************************************
*
*					 Helper Routines
*
****************************************************/

// Returns vertices for basic polygon shape
function getPolyPts(cX, cY, r, vCount, aOffset)
{
	var a = 0 ;
	var x = 0 ;
	var y = 0 ;

	var pts = [] ;

	for(var i = 0; i < vCount; i++)
	{
		a = aOffset + 2 * Math.PI / vCount * i ;
		x = cX + r * Math.cos(a) ;
		y = cY + r * Math.sin(a) ;

		pts.push([Math.round(x),Math.round(y)]) ;
	}

	return pts ;
}

// Lifted from http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
// Does all the work for drawRoundedPoly() far as putting pixels down
function doPolyDraw(ctx, pts, cRad, opac)
{
	if (cRad > 0) pts = getRoundedPoints(pts, cRad);

	var pt = [] ;
	
	ctx.beginPath() ;

	for(var i = 0; i < pts.length; i++)
	{
    	pt = pts[i];

    	if (i == 0) ctx.moveTo(pt[0], pt[1])
   		else ctx.lineTo(pt[0], pt[1])

   		if (cRad > 0) ctx.quadraticCurveTo(pt[2], pt[3], pt[4], pt[5]);
    }

  	ctx.closePath();

  	ctx.strokeStyle = 'rgba(255,255,255,' + opac + ')' ;
  	ctx.stroke() ;
}


// Takes an array of points from getPolyPts
// And generates points for quadratic curves
function getRoundedPoints(pts, cRad)
{
	var i1, i2, i3, p1, p2, p3 ;

	var prevPt = [] ;
	var nextPt = [] ;

    var len = pts.length ;
    var res = new Array(len) ;

  	for (i2 = 0; i2 < len; i2++)
  	{
	    i1 = i2 - 1 ;
	    i3 = i2 + 1 ;
	    
	    if (i1 < 0) 	i1 = len - 1 ;
	    if (i3 == len) 	i3 = 0 ;
	    
	    p1 = pts[i1];
	    p2 = pts[i2];
	    p3 = pts[i3];
	    
	    prevPt = getRoundedPoint( p1[0], p1[1], p2[0], p2[1], cRad, false ) ;
	    nextPt = getRoundedPoint( p2[0], p2[1], p3[0], p3[1], cRad, true ) ;
	    
	    res[i2] = [ prevPt[0], prevPt[1], p2[0], p2[1], nextPt[0], nextPt[1] ] ;
  	}

  	return res ;
}

function getRoundedPoint(x1, y1, x2, y2, cRad, first)
{
	var total 	= Math.sqrt( Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) ) ;
    var idx 	= first ? cRad / total : ( total - cRad ) / total ;
  	
  	return [ Math.round(x1 + (idx * (x2 - x1))), Math.round(y1 + (idx * (y2 - y1))) ] ;
}

function degToRad(d)
{
	return (d / 360) * 2 * Math.PI ;
}

function radToDeg(r)
{
	var d = (r / (2 * Math.PI)) * 360
	console.log('converting to degrees: '+r+', '+d) ;
	return d ;
}

function randomInt(min, max)
{
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

</script>

<!--                                  -->
<!--                 CSS              -->
<!--                                  -->
<style>

#thebody
{
	padding: 		0 ;
	border: 		0 ;
	margin: 		0 ;
	width: 			1024px ;
	height: 		768px ;
	overflow: 		hidden ;

	background:		black ;
}

.bg-layer
{
	background-position: center ;
	position: absolute ;
	opacity: 1.0 ;
	width: 1024px ;
	height: 768px ;

	-webkit-transition: opacity 6s;
}

#shard-container, #bubble-container, #geom-1, #geom-2
{
	position: 		absolute ;
	width: 			1024px ;
	height: 		768px ;
}

#bubble-sprite
{
	z-index: 10000 ;
	border: 2px solid red ;
	width: 840px ;
	height: 120px ;
	opacity: 0.2 ;
}

#gcell-sprite
{
	z-index: 10000 ;
	border: 2px solid green ;
	width: 240px ;
	height: 240px ;
	opacity: 1.0 ;

	top: 300px ;
}

#shard-sprite
{
	z-index: 10000 ;
	border: 2px solid yellow ;
	width: 48px ;
	height: 12px ;
	opacity: 1.0 ;

	top: 400px ;
}

#revolver-cyl
{
	position: absolute ;
	width: 130px ;
	height: 130px ;
	background: url('img/revolver-cyl.png') ;
	left: 447px ;
	top: 15px ;

	/* -webkit-transition-timing-function: ease-in-out ; */
	-webkit-transition: -webkit-transform 1s;
}

.bullet
{
	-webkit-transition: opacity 0.5s;
}

#g-cnv{
	position: absolute ;
	/* double native canvas size for fullscreen */
	width: 1024px ;
	height: 768px ;
	z-index: 100 ;
	-webkit-transition: opacity 5s;
	-webkit-transform: translateZ(0) ;
}

.bubble-canvas
{
	-webkit-transition: opacity 10s, -webkit-transform 10s ;
}

#hmt
{
	position: absolute ;
	display: block ;
	z-index: 2000 ;
	right: 20px  ;
	top: 20px ;
	width: 200px ;
	height: 30px ;
	font-size: 11px ;
	font-family: verdana, arial, helvetica, sans-serif ;
	background: white ;
	text-align: center ;
}

</style>
</body>

<script>window.setTimeout('main()',500)</script>
</html>