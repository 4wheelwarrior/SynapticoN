<html>
<head>

<title>SynapticoN</title>

<script src="phonegap.js"></script>
<script src="tween.js"></script>

<script>
/*
A few random notes ...

- Implement a sound queue ... SFX get cued in a chain, returns to loop when all done
*/
var C_DISAUDIO				= false ;
var C_TAPEVENT				= 'touchstart' 	// 'touchstart' or 'click' for iPad or Desktop...
// #SEC_JSHEAD
var C_TTICK_INT   			= 333 ;		// Tween ticker interval (msec)
var C_SEGS 					= 6 ;		// Intrinsic to FOL design. This will ALWAYS be 6...
var C_RBMIN					= 20 ;		// Min value of base radius (native canvas size)
var C_RBMAX					= 40 ;		// Max value of base radius (display size will be 2x this)
var C_IAMAX					= 12 ;		// Maximum _AOFFSET reached before we wrap around to zero
										// (12 * 137.5 = 1650 degrees)


var C_MWIDTH 				= 1024 ;	// Mandala base size (starts here, scales up)
var C_MHEIGHT 				= 768 ;

var C_MSCALE_MAX 			= 0.15 ;	// Scale mandala UP by this factor before fading out
										// EG 0.3 = 30% means 800px will scale to 800 + (30% * 800)
													
var C_MOPAC_MIN				= 0.0 ;		// Min/Max opacities of mandalas as they grow
//var C_MOPAC_MAX				= 0.15 ;

var C_MOPAC_MAX 			= [0.20,0.15,0.35,0.20,0.10,0.10,0.20] ;

var C_MSCALE_DUR			= 12000 ;	// Duration of life and death cycle (total cycle is 2x)
var C_MSPAWN_INT  			= 6000 ;	// Interval on which new mandalas are spawned

var C_BUB_SPAWNPROB			= 0.2 ;		// Probability of a spawn each time spawnBubble() called
var C_BUB_MAX				= 6 ;		// Max # of bubbles on screen simultaneously
var C_BUB_LSPAN_MIN			= 4000 ; 	// Min lifespan of a bubble (msec)
var C_BUB_LSPAN_MAX			= 8000 ;	// Max lifespan
var C_BUB_RADIUS_MIN		= 30 ;		// Min radius of bubble (pixels)
var C_BUB_RADIUS_MAX		= 70 ;		// Max radius
//var C_BUB_OPAC_MIN			= 0.15 ;	// Min opacity of bubble (0 - 1.0, css opacity)
//var C_BUB_OPAC_MAX			= 0.30 ;	// Max opacity

var C_BUBDX_MIN				= -1 ;		// "Bubble Dynamics" ... roughly put
var C_BUBDX_MAX				= 1 ;

var C_BUBDY_MIN				= -1 ;
var C_BUBDY_MAX				= 1 ;

var C_BUBDWS_MIN			= 80 ;		// These get divided by 100 to produce an actual scale value
var C_BUBDWS_MAX			= 120 ;		// Between 0.8 and 1.2

var C_BUBDHS_MIN			= -1 ;
var C_BUBDHS_MAX			= 1 ;

var C_BUB_OPAC 				= [0.25,0.20,0.25,0.20,0.10,0.10,0.20] ;

var C_BUB_FADEIN			= 3000 ;	// ms for a bubble to fade into existence
var C_BUB_EDGEPAD			= 10 ;		// Padding for bubble region (from screen edges)
var C_BUB_EXPRATE			= 1 ;		// Expansion rate of bubble's radius (pixels per tick)

var C_BUB_PBOPAC			= 0.40 		// Bubble opacity becomes this value before bursting
var C_BUB_PBEXP				= 0.13 ;	// Bubble scales up by this factor before bursting
var C_BUB_GEOM				= [ [99], 	// Which polygons for each colour.Starting @ RED
								[99], 					// ORG
								[3,4,99],				// YEL
								[99],					// GRN
								[5,6,99],				// BLU
								[5,6,7,8,99],			// IND
								[3,4,5,6,7,8,9,99]		// VIO
							  ] ;		// Index can piggyback off _bgIdx

var C_BUB_CRAT				= 0.16; 	// Corner radius of polygon bubbles, ratio of radius

var C_HIT_CONSEC			= 5 ;		// # of consecutive hits/misses required to trigger life loss or gain


var C_UBR_INT				= 500 ;		// ms between calls of updateBubReg()
var C_UBD_INT				= 2000 ;    // ms between calls of updateBubDyn()

var C_USR_INT				= 250 ;   	// ms between calls of updateShardReg()
var C_SGC_INT				= 2000 ;	// ms between calls of shardRegGC()
var C_SBB_INT				= 1000 ;	// ms between calls to spawnBubble()
										// TODO: lock this to soundtrack instead

var C_HMQ_INT				= 100 ;		// ms between calls to processHMQ()
var C_TON_INT				= 3236 ;	// ms between calls to playTone()

// PHI... calculated by its mathematical definition
var C_PHI 					= ( 1 + Math.sqrt(5) ) / 2 ;

// 137.5 degrees expressed as radians
// This is the inside angle formed when a circle is divided
// into two arcs, their lengths being PHI in proportion...
var C_DA 					= 2.39982772 ;

var C_SDIST_ORG				= 30 ; 		// Shard distribution "organic" factor (+/- this many degrees)
var C_BLSTRAD_ORG			= 30 ; 		// Shard "blast radius" organic factor (percentage of nominal radius)
var C_SVELOC				= 20 ;		// Shard velocity expressed as # of ticks to full radius
var C_SHARDPAD 				= 10 ;


// Starting times of each audio loop
// They're all the same length
var C_LOOP_DICT 	= [0,3,6,9,12,15,18] ;

// Start times and durations of all other sound effects
// Used by playSfx() function to cue and then pause after a delay
// In order, these are: 0:burst, 1:gun cock, 2:gun fire, 3:life up, 4:life down, 5:game over
var C_SFX_DICT		= [[21,1800],[23,1200],[25,2200],[28,1200],[30,1200],[32,7000]] ;

/*
Block comment here ... yakkity yak

*/

// Globals for interval tickers (needed so we can clear them later)

var _ITWN ; // tween ticker
var _ITTS ; // tap to start flasher
var _IBSP ; // bubble spawner
var _ISWC ; // swap colour
var _IUBR ; // updateBubReg
var _IUBD ; // updateBubDyn
var _ICDN ; // coundown sequence at beginning
var _IMSP ; // mandala spawn interval
var _ILPP ;	// audio loop
var _IHMQ ; // process hit/miss queue
var _IUSR ; // updateShardReg() ;
var _ISGC ; // shardRegGC() ;

// Screen resolution of device
var _SCRWID				= 1024 ;
var _SCRHGT				= 768 ;

// Total number of bubbles spawned
var _BUB_TOTAL 			= 0 ;

// Total number of bubbles hit
var _BUB_HIT 			= 0 ;

// Hit/Miss queue. FIFO, new elements PUSHED on
// Stores 2 for hit, 1 for miss
var _HMQ				= [] ;
var _HMQ_TIMER			= 0 ;

// "Hit Accumulator"
// Counts up every time a hit is accumulated, down for misses
// When it reaches 0, death. 10, life. 'Center' is 5.
var _HIT_ACC			= 5 ;

// Life Force. If it reaches zero, game over
// Every time 5 consecutive bubbles are missed, lose 1
// Every time 5 consecutive bubbles are hit, gain 1
// Brain is constantly tracking this number ... we don't display it
// Initially, focused on figuring out what it is!
var _LF					= 3 ;

// Bubble registry (keeps track of all bubbles on screen)
// Each entry is also an array [domRef,lspan]
// domRef is pointer to <canvas> object
// lspan is number of milliseconds until <canvas> is removed
// each time updateBubReg() ticks, lspan is decremented proportionally
// i.e. if updateBubReg() is on a 100ms interval, decrement is 10 (1/10th of a second)
var _BUBREG				= [] ;

// Tracks explosive shards
var _SHARDREG			= [] ;

// One for now, eventually have variations.
// These are initialized later ...
var _SND_BURST ;
var _SND_TONE ;

// Index of current BG colour (i.e. which one gets faded when nextBg is called)
// Other sequences are keyed off this too ... opacities, sound loops, geometry, etc
var _bgIdx 				= 0 ;

// Mandala canvases
var _M	= [] ;			// DOM pointers to mandala canvases

var _IM	= 0 ;			// Index of mandala canvas being drawn

var _RBASE ;			// Base radius of mandala set being drawn
var _R ;				// Radius of current mandala being drawn
var _IA	;				// Multiplier  on _DA to determine offset angle of mandala

var _AUDIO ;			// HTML5 audio object
var _ILOOP ;			// Interval handling audio loop
var _AUD_TIMEOUT ;		// Audio timeout counters (for re-pausing after a delay)

var _PAUSESG = false ;	// Can be toggled to pause SG animations when doing visual FX overtop

var _elSc ;				// Points to shard container for showing/hiding without doing getElById lookups

function doAudioLoop()
{
    if(C_DISAUDIO) return 0 ;

    _AUDIO.currentTime = C_LOOP_DICT[_bgIdx] ;
    if(_AUDIO.paused) _AUDIO.play() ;

    window.clearTimeout(_AUD_TIMEOUT) ;
    _AUD_TIMEOUT = window.setTimeout('pauseAudio()',2200) ; // Stop after 2.2s
}

function playAudio()
{
    if(C_DISAUDIO) return 0 ;

    _AUDIO.play() ;
}

function pauseAudio()
{
    if(C_DISAUDIO) return 0 ;

    _AUDIO.pause() ;
}

function playSfx(i)
{
	if(C_DISAUDIO) return 0 ;
	
	var startTime = C_SFX_DICT[i][0] ;
	var pauseTime = C_SFX_DICT[i][1] ;

	// Cue to start time, play if not already playing
	_AUDIO.currentTime = startTime ;
	if(_AUDIO.paused) _AUDIO.play() ;
    
    // Clear any pending pause timeouts
    window.clearTimeout(_AUD_TIMEOUT) ;

    // Set a new timeout to pause after this sound is done
    _AUD_TIMEOUT = window.setTimeout('pauseAudio()',pauseTime) ;
}

// TODO: move these into proper position. Same with audio shit above.

var _WBBL = 120 ; // center point will be _WBBL/2, _WBBL/2
var _RBBL = 34 ; // Radius from center of barrel to center of bullet holes
var _WBUL = 34 ; // Interesting coincidence with above ... !
var _AOFF = Math.PI / 2 - ( 2 * Math.PI / 5 ) ; // initial offset angle, 90* due north minus 360/5 = 72deg from top

var _ABBL = 0 ;
var _DABBL = 72 ; // 72deg is increment

var _ICLR ; // Interval to clear bullets

// Called every 100ms to ensure quick response
// Once bubble is popped
function processHMQ()
{
	//console.log('Hit accumulator '+_HIT_ACC) ;
	document.getElementById('lf').innerHTML = 'HIT ACC: '+_HIT_ACC ;
	if(!_HMQ.length) return ;

	_HMQ_TIMER-- ;

	// Wait until current HMQ entry is processed
	// i.e. done animating, until proceeding
	if(_HMQ_TIMER > 0) return false ;

	// If hit accumulator has reached zero, trigger death sequence
	if(_HIT_ACC <= 0){ deathSequence() ; return 0 }

	// If hit accumulator has reached 10, trigger 'fire-at-synapticon' sequence
	if(_HIT_ACC <= 0){ playSfx(3) ; emptyBullets(); _HIT_ACC = 5; return 0 }

	// If timer has run down, process the next entry ...
	var ent = _HMQ.shift() ;

	if(ent == 'M')
	{
		// If hits have been accumulated, 
		// clear them and re-center hit accumulator
		if(_HIT_ACC > 5)
		{
			_HIT_ACC = 4 ; // (5 is center, minus the miss we're processing)

			emptyBullets() ;

			// Allow time for emptyBullets() to finish running
			window.setTimeout(function(){
				addBullet(0) ;
				window.setTimeout(function(){ playSfx(1) ; rotateRight() },200) ;
			},800) ;

			// Allow time for empty animation AND load animation
			_HMQ_TIMER = 16 ;
			return ;
		}

		_HIT_ACC-- ;

		// Parameter isRear, zero... meaning pointing at player
		addBullet(0) ;

		window.setTimeout(function(){ playSfx(1) ; rotateRight() },200) ;
	}

	if(ent == 'H')
	{
		// If misses have been accumulated, 
		// clear them and re-center hit accumulator
		if(_HIT_ACC < 5)
		{
			// Re-center hit accumulator
			_HIT_ACC = 6 ; // (5 is center, plus the hit we're processing)

			emptyBullets() ;

			// Allow time for emptyBullets() animation to finish
			window.setTimeout(function(){
				addBullet(1) ;
				window.setTimeout(function(){ playSfx(1) ; rotateLeft() },200) ;
			},800) ;
			
			// Allow time for empty animation AND load animation
			_HMQ_TIMER = 16 ;
			return ;
		}

		// Normal behaviour ... (ie. not waiting for empty() animation to finish
		// Before adding the bullet)
		// Register the hit
		_HIT_ACC++ ;

		// Add bullet, and after a short delay ... rotate it into place
		addBullet(1) ;
		window.setTimeout(function(){ playSfx(1) ; rotateLeft() },200) ;
	}

	// Set timer, allow time for barrel to finish rotating.
	// IMPORTANT: this isn't in milliseconds. HMQ processes
	// every 100ms, so this value TIMES 100 is the number of ms.
	_HMQ_TIMER = 11 ;
}

function addBullet(isRear)
{
	var src ;
	var ang ;

	if(isRear) src = 'img/bullet-rear.png' ;
	else src = 'img/bullet-front.png' ;

	var el = document.createElement('img') ;
	var x = Math.round(_WBBL/2) ;
	var y = x ;

	ang = _AOFF + degToRad(_ABBL) ; // derive angle from current barrel angle ...

	x = Math.round(x + _RBBL * Math.cos(ang) - _WBUL / 2 ) ;
	y = Math.round(y - _RBBL * Math.sin(ang) - _WBUL / 2 ) ;

	el.style.position = 'absolute' ;
	el.src = src ;
	el.style.left = x + 'px' ;
	el.style.top = y + 'px' ;
	el.style.zIndex = 15500 ;

	// Randomize rotation (organic detail for bullet rears... lettering, etc)
	el.style.webkitTransform = 'rotate('+randomInt(0,360)+'deg)' ;

	document.getElementById('revolver-bbl').appendChild(el) ;
}

function triggerHit()
{
	if(_BUB_CMISS > 0)
	{
		emptyBullets() ; // will reset hit/miss values

		// Timeout needs to allow emptyBullets to finish ...
		window.setTimeout(function(){
			rotateRight() ;
			window.setTimeout(function(){addBullet()},800) ;
			_BUB_CHIT++ ;
		},1100) ;

		return ;
	}

	// Otherwise, rotateLeft() can happen immediately ...
	rotateRight() ;
	window.setTimeout(function(){ addBullet() },800) ;
	
	_BUB_CHIT++ ;
}

function triggerMiss()
{
	if(_BUB_CHIT > 0)
	{
		emptyBullets() ; // will reset hit/miss values

		// Timeout needs to allow emptyBullets to finish ...
		window.setTimeout(function(){
			rotateLeft() ;
			window.setTimeout(function(){ addBullet(1) },800) ;
			_BUB_CMISS ++ ;
		},1100) ;

		return ;
	}

	// Otherwise, rotateLeft() can happen immediately ...
	rotateLeft() ;
	window.setTimeout(function(){ addBullet(1) },800) ;

	_BUB_CMISS++ ;
}

function rotateRight()
{
	_ABBL += _DABBL ;
	document.getElementById('revolver-bbl').style.webkitTransform = 'rotate('+_ABBL+'deg)' ;
}

function rotateLeft()
{
	_ABBL -= _DABBL ;
	document.getElementById('revolver-bbl').style.webkitTransform = 'rotate('+_ABBL+'deg)' ;
}

function rotateZero()
{
	_ABBL = 0 ;
	var el = document.getElementById('revolver-bbl') ;

	el.style.webkitTransform = '' ;
	el.style.webkitTransform = 'rotate('+_ABBL+'deg)' ;
	el.style.webkitTransition = '-webkit-transform 1s' ;
}

// Called when 'spin to zero' is initiated... sequentially removes bullet elements
function emptyBullets()
{
	_BUB_CHIT = 0 ;
	_BUB_CMISS = 0 ;

	// Rotate barrels back to zero
	rotateZero() ;

	// Remove bullets from chamber
	var aChildren = document.getElementById('revolver-bbl').children ;
	var el ;
	for(var i = 0; i < aChildren.length; i++)
	{
		console.log('Removing from chamber ...') ;
		el = aChildren[i] ;
		el.parentNode.removeChild(el) ;
	}

	// Spawn bullets, dump them on the ground!!
	// CSS class SHOULD initialize position to off screen top ...
	// Then setting new values SHOULD cause them to drop
	var shellCount ;
	if(_HIT_ACC > 5) shellCount = _HIT_ACC - 5 ;
	if(_HIT_ACC < 5) shellCount = 5 - _HIT_ACC ;

	for(var i = 0; i <= shellCount ; i++)
	{
		el = document.createElement('img') ;
		el.className = 'bullet-side' ;
		el.src = 'img/bullet-side.png' ;

		// I suppose inserting the fuckin' thing into the DOM would be a good idea ...
		document.getElementById('thebody').appendChild(el) ;
	}

	// After a short delay, setting new values sends em on the way.
	window.setTimeout(function(){
		var el ;
		var bullets = document.getElementsByClassName('bullet-side') ;
		
		for(var j = 0; j < bullets.length; j++)
		{
			el = bullets[j] ;

			el.style.left = randomInt(400,600) + 'px' ;
			el.style.top = '400px' ;
			el.style.webkitTransform = 'rotate(' + randomInt(0,720) + 'deg)' ;
			el.style.opacity = 0 ;
		}
	},50) ;

	// After 5s, remove shells from DOM
	window.setTimeout(function(){
		var bullets = document.getElementsByClassName('bullet-side') ;
		for(var i = 0; i < bullets.length; i++)
		{
			bullets[i].parentNode.removeChild(bullets[i]) ;
		}
	},5000) ;


	// Pause SG, give rotate and bullet fall animations 2s to run, then restart it
	_PAUSESG = true ;
	window.setTimeout(function(){_PAUSESG = false}, 2000) ;
}

function tClearBullet()
{
	// Get a list of remaining bullet elements
	var aChildren = document.getElementById('revolver-bbl').children
	var el = aChildren[aChildren.length - 1] ;
	
	if(!el)
	{
		window.clearInterval(_ICLR) ;
		return ;
	}

	el.parentNode.removeChild(el) ;
}

</script>
</head>
<!-- #SEC_HTML -->
<body id="thebody" style="margin:0; padding:0; overflow: hidden">
	<a id="bn-hide"
	   style="position: absolute; z-index: 15500; width: 100px; height: 100px"
	   href="javascript:hideBN()"></a>

	<script>
		function hideBN()
		{
			document.getElementById('build-number').style.display = 'none' ;
			document.getElementById('bn-hide').style.display = 'none' ;
		}
	</script>
	<iframe id="build-number"
	        style="position:absolute; z-index: 15000; background:white; width: 80px; height: 30px; padding: 0"
	        src="build.txt"></iframe>
	<div id="lf">H:xx | M:xx | L: 3</div>

	<div id="revolver-bbl"></div>

	<audio id="snd-sprite" preload="auto">
		<source src="snd/sound-sprite-proto.wav">
	</audio>

	<div id="title-lettr-title"></div>
	<!-- display:none goes inline, otherwise JS can't read it -->
	<div id="title-lettr-tapstart" style="display:none"></div>
	
	<div id="title-bg-black"></div>
	
	<div id="dlog-start">
		<img 	src="img/lettr-popbubs.gif"
				 	style="position: absolute; left:94px; top:130px; opacity: 0.66" />
					
		<img 	src="img/lettr-ready.gif" id="lettr-ready"
					style="position: absolute; left:196px; top:205px; opacity: 0" />
					
		<img  src="img/dig-3.gif" id="countdown-digit"
					style="position: absolute; left:307px; top:205px; display:none" />
					
		<img  src="img/sym-dot.gif" id="countdown-dot-1"
					style="position: absolute; left:337px; top:205px; display:none" />
					
		<img  src="img/sym-dot.gif" id="countdown-dot-2"
					style="position: absolute; left:350px; top:205px; display:none" />
					
		<img  src="img/sym-dot.gif" id="countdown-dot-3"
					style="position: absolute; left:365px; top:205px; display:none" />
	</div>
	
	<div id="dlog-end">
		<!-- wrapper to conveniently set opacity on total/popped & digits -->
		<div style="opacity: 0.66">
			<!-- width gets expanded to full width, 360px, via tween -->
			<div style="position: absolute; left:41px; top:59px; width: 73px; height: 21px;
									background: url('img/lettr-total.gif') no-repeat; display: none"
					 id="lettr-total"></div>
			
			<!-- same expansion happens here -->
			<div style="position: absolute; left:41px; top:105px; width: 94px; height: 27px;
									background: url('img/lettr-popped.gif') no-repeat; display: none"
					 id="lettr-popped"></div>
			
			<!-- digits for total bubble count -->
			<!-- ordinal values for digit ID's correspond to order
			     in which 1's, 10's, 100's places are calculated in the code -->
			<img  src="img/dig-0.gif" id="total-dig-0"
						style="position: absolute; left:420px; top:59px; display:none; opacity: 0" />
			<img  src="img/dig-0.gif" id="total-dig-1"
						style="position: absolute; left:442px; top:59px; display:none; opacity: 0" />
			<img  src="img/dig-0.gif" id="total-dig-2"
						style="position: absolute; left:464px; top:59px; display:none; opacity: 0" />
						
			<!-- digits for popped bubble count -->
			<img  src="img/dig-0.gif" id="popped-dig-0"
						style="position: absolute; left:420px; top:105px; display:none; opacity: 0" />
			<img  src="img/dig-0.gif" id="popped-dig-1"
						style="position: absolute; left:442px; top:105px; display:none; opacity: 0" />
			<img  src="img/dig-0.gif" id="popped-dig-2"
						style="position: absolute; left:464px; top:105px; display:none; opacity: 0" />
		</div>
		<img  src="img/lettr-score.gif"
					style="position: absolute; left:148px; top:233px; display:none"
					id="lettr-score" />
					
				<!-- digits for popped bubble count -->
		<img  src="img/dig-0.gif" id="score-dig-2"
					style="position: absolute; left:320px; top:231px; display:none; opacity: 0" />
		<img  src="img/dig-8.gif" id="score-dig-1"
					style="position: absolute; left:339px; top:231px; display:none; opacity: 0" />
		<img  src="img/dig-7.gif" id="score-dig-0"
					style="position: absolute; left:360px; top:231px; display:none; opacity: 0" />
	</div>
	
	<!-- TODO: replace this with dynamically generated mandala -->
	<div id="title-bg-mandala"></div>
	
	<div id="bubble-container"></div>
	<div id="shard-container"></div>

	<div id="scan-lines"></div>

	<div id="red-matte"></div>

	<div id="mandala-container">
		<canvas width="512" height="384" id="mandala-0" style="z-index: 100"></canvas>
		<canvas width="512" height="384" id="mandala-1" style="z-index: 90"></canvas>
		<canvas width="512" height="384" id="mandala-2" style="z-index: 80"></canvas>
	</div>
	
	<!-- these layers "peel away" as colours change -->
	<div class="bg-layer" id="bg-0" style="z-index: 70; background:url('img/bg-red.png')"></div>
	<div class="bg-layer" id="bg-1" style="z-index: 60; background:url('img/bg-org.png')"></div>
	<div class="bg-layer" id="bg-2" style="z-index: 50; background:url('img/bg-yel.png')"></div>
	<div class="bg-layer" id="bg-3" style="z-index: 40; background:url('img/bg-grn.png')"></div>
	<div class="bg-layer" id="bg-4" style="z-index: 30; background:url('img/bg-blu.png')"></div>
	<div class="bg-layer" id="bg-5" style="z-index: 20; background:url('img/bg-ind.png')"></div>
	<div class="bg-layer" id="bg-6" style="z-index: 10; background:url('img/bg-vio.png')"></div>
	
	<script language="javascript">window.setTimeout('titleSequence1()',200)</script>
	<!-- <script language="javascript">document.location.href = 'index2.html'</script> -->
	<!-- #SEC_CSS -->
<style>
html,body{
    background: black ;
    width: 1024px ;
    height: 768px ;
}

#lf{
	font-size: 15px ;
	font-family: tahoma, verdana, helvetica, arial, sans-serif ;
	color: black ;
	background: white ;
	border: 3px solid black ;
	text-align: center ;
	position: absolute ;
	left: 820px ;
	top: 5px ;
	width: 150px ;
	height: 30px ;
	z-index: 20000 ;
}

#revolver-bbl
{
	position: absolute ;
	width: 120px ;
	height: 120px ;
	background: url('img/barrels.png') ;
	left: 452px ;
	top: 15px ;

	z-index: 20000 ;

	-webkit-transition-timing-function: ease-in-out ;
	-webkit-transition: -webkit-transform 1s;
}

.bullet-side{
	position: absolute ;
	top: 100px ;
	left: 400px ;
	z-index: 19500 ;

	-webkit-transition: all 2s ease-in ;
	/*
	-webkit-transition-timing-function: ease-in ;
	-webkit-transition-duration: 2s ;
	-webkit-transition-property: left ;
	-webkit-transition-property: top ;
	-webkit-transition-property: webkit-transform ;
	*/
}

#title-tapstart-region{
	position: absolute ;
	width: 1024px ;
	height: 768px ;
	z-index: 700 ;
}

#title-lettr-title{
	position: absolute ;
	z-index: 620 ;
	width: 356px ;
	height: 110px ;
	left: 334px ;
	top: 300px ;
	background: url('img/lettr-title.png') ;
}

#title-lettr-tapstart{
	position: absolute ;
	z-index: 620 ;
	width: 324px ;
	height: 30px ;
	left: 350px ;
	top: 420px ;
	background: url('img/lettr-tapstart.gif') ;
	opacity: 0.51 ;
}

#title-bg-black{
	position: absolute ;
	width: 1024px ;
	height: 768px ;
	z-index: 600 ;
	background: #000 ;
}

#title-bg-mandala{
	position: absolute ;
	width: 1024px ;
	height: 768px ;
	z-index: 500 ;
	background: url('img/bg-mandala.jpg') ;
	background-position: center ;
}

#dlog-start{
	position: absolute ;
	width: 542px ;
	height: 322px ;
	left: 241px ;
	top: 223px ;
	background: url('img/dlog-bg.png') ;
	z-index: 620 ;
	opacity: 0 ;
}

#dlog-end{
	position: absolute ;
	width: 542px ;
	height: 322px ;
	left: 241px ;
	top: 223px ;
	background: url('img/dlog-bg.png') ;
	z-index: 620 ;
	opacity: 0 ;
}

#mandala-container{
    position: absolute ;
    width: 1024px ;
    height: 768px ;
    overflow: hidden ;
}

#bubble-container{
		position: absolute ;
		width: 1024px ;
		height: 768px ;
		z-index: 1000 ;
}

#shard-container{
		position: absolute ;
		width: 1024px ;
		height: 768px ;
		z-index: 900 ;
}

#scan-lines{
 		width: 1024px ;
 		height: 768px ;
 		position: absolute ;
		z-index: 995 ;
		background: url('img/scan-lines.png') no-repeat ;
		opacity: 0.05 ;
		display: none ;
}

#red-matte{
	width: 1024px ;
	height: 768px ;
	position: absolute ;
	z-index: 20000 ;
	display: none ;
	opacity: 0 ;
	background: url('img/red-matte.png') ;
}

#mandala-1, #mandala-2, #mandala-3{
    position: absolute ;
    width: 1024px; /* double size */
    height: 768px ; /* double size */
}

.bg-layer{
	background-position: center ;
	position: absolute ;
	opacity: 1.0 ;
	width: 1024px ;
	height: 768px ;
}

.shard{
	/*-webkit-transition-property: left, top, opacity, width ; */
	/* -webkit-transition-duration: 500ms ; */
	/* ease | linear | ease-in | ease-out | ease-in-out */
	/* -webkit-transition-timing-function: ease-out ; */
	display: block ;
	position: absolute ;
	z-index: 3000 ;
	opacity: 0.6 ;
}
</style>
<!-- #SEC_JSSG -->
<script language="javascript">
function initSgGen()
{
	_M[0] 	= document.getElementById('mandala-0') ;
	_M[1] 	= document.getElementById('mandala-1') ;
	_M[2] 	= document.getElementById('mandala-2') ;
	
	_RBASE 	= randomInt(C_RBMIN, C_RBMAX) ;
	_IA		= randomInt(0, C_IAMAX) ;
	
	spawnMandalaCycle() ;
	_IMSP 	= window.setInterval('spawnMandalaCycle()',C_MSPAWN_INT) ;
}

function spawnMandalaCycle()
{
	var a ; 			// offset angle (which angle we start drawing at)
	var r ; 			// radius (of each 'cell' within the mandala)
	var cnv ; 		// mandala canvas element
	var ctx ; 		// 2d context from mandala canvas
  
	// Wrap angle around to zero if we've reached the max
	// EXPLANATION: When angle reaches 1650 degrees, the next 137.5 degrees
	// Takes us to 1787.5 degrees, which is equivalent to 347.5 degrees.
	// Instead of going to 347.5 degrees, we'll jump to 360 (zero degrees)
	// Yep, it's off by 12.5 degrees... but that is a very small angle!
	if(_IA == C_IAMAX ) _IA = 0 ;
	
	// If we've drawn the third mandala,
	// reset _IM and re-randomize _RBASE
	if(_IM > 2)
	{
		_RBASE = randomInt(C_RBMIN,C_RBMAX) ;
		_IM = 0 ;
	}
	
	cnv = _M[_IM] ;
	ctx = cnv.getContext('2d') ;
	r 	= _RBASE * Math.pow(C_PHI,_IM) ;
	a 	= _IA * C_DA ;
	
	// Reset canvas opacity and size before redrawing
	cnv.style.display = 'none' ;
	cnv.style.opacity = 0 ;
	cnv.style.width 	= C_MWIDTH + 'px' ;
	cnv.style.height	= C_MHEIGHT + 'px' ;
	cnv.style.display = 'block' ;
	
	// Remember, "native size" of canvas is HALF of nominal width/height
	ctx.clearRect(0, 0, C_MWIDTH / 2, C_MHEIGHT / 2) ;
	
	// Draw flower of life, centered on the canvas
	// using previously calculated 'r' and 'a' values
	// Remember, again, the native size of the canvas ...
	// center of canvas will be (C_MWIDTH / 4)
	drawFol(ctx, C_MWIDTH / 4, C_MHEIGHT / 4, r, a) ;
	
	// Set off chain of scale/fade tweens, which will
	// eventually call 'spawnMandalaCycle' again
	mGrowCycle(cnv) ;

  // Thanks to CSS transforms, all we do is this ...
  //cnv.className = 'm-cycle' ;
	
	// Advance to next canvas and next angle
	// For the next time this fn is called...
	_IM++ ;
	_IA++ ;
}

function mGrowCycle(cnv)
{
	var twn = { s: 0, o: C_MOPAC_MIN } ;
  	var eas = TWEEN.Easing.Quartic.Out ;
  
	new TWEEN.Tween( twn )
      .to( { s:C_MSCALE_MAX, o:C_MOPAC_MAX[_bgIdx] }, C_MSCALE_DUR )
      .easing( eas )
      .onComplete(function(){
      		mDeathCycle(cnv) ;
      	})
      .onUpdate( function () {
          cnv.style.opacity = twn.o ;
          scaleFromCenter(cnv,twn.s) ;
      }).start();
}

function mDeathCycle(cnv)
{
	var twn = { s: C_MSCALE_MAX, o: C_MOPAC_MAX[_bgIdx] } ;
  	var eas = TWEEN.Easing.Quartic.Out ;
  
	new TWEEN.Tween( twn )
      .to( { s: 2 * C_MSCALE_MAX, o:0 }, C_MSCALE_DUR )
      .easing( eas )
      .onComplete(function(){}) // new mandala cycle already got spawned ...
      .onUpdate( function () {
          cnv.style.opacity = twn.o ;
          //scaleFromCenter(cnv,twn.s) ;
      }).start();
}


/*************************************************

   DRAWING FUNCTIONS (MANDALAS, BUBBLES, DIGITS)

**************************************************/


function drawFol(ctx, cx, cy, r, ao){
    var a ;
    var x ;
    var y ;

    drawSol(ctx, cx, cy, r, ao) ;

    for(var i = 0; i < C_SEGS; i++){
        a = ao + (i + 1) * (2 * Math.PI / C_SEGS) ;
        x = Math.round(cx + 2 * r * Math.cos(a)) ;
        y = Math.round(cy + 2 * r * Math.sin(a)) ;

        drawSol(ctx, x, y, r, a) ;
    }
}

function drawSol(ctx, cx, cy, r, ao){
    var a ;
    var x ;
    var y ;

    drawCell(ctx, cx, cy, r) ;

    for(var i = 0; i < C_SEGS; i++){
        a = ao + (i + 1) * (2 * Math.PI / C_SEGS) ;
        x = Math.round(cx + r * Math.cos(a)) ;
        y = Math.round(cy + r * Math.sin(a)) ;
        drawCell(ctx, x, y, r) ;
    }
}

function drawCell(ctx, cx, cy, r){
    var cR = 255 ;
    var cG = 255 ;
    var cB = 255 ;

    var rg = ctx.createRadialGradient(cx, cy, 10, cx, cy, r) ;

    rg.addColorStop(0, 		'rgba('+cR+', '+cG+', '+cB+', 0.0)') ;
    rg.addColorStop(0.6, 	'rgba('+cR+', '+cG+', '+cB+', 0.0)') ;
    rg.addColorStop(0.9, 	'rgba('+cR+', '+cG+', '+cB+', 0.2)') ;
    rg.addColorStop(1, 		'rgba('+cR+', '+cG+', '+cB+', 0.5)') ;

    ctx.beginPath() ;
    ctx.arc(cx, cy, r, 0, 2 * Math.PI, false) ;
    ctx.fillStyle = rg ;
    ctx.fill() ;
}

// Scales mandala canvas M around its center point
// by a factor of 's' where 0 < s < 1.0
function scaleFromCenter(M,s)
{
	var w, h, cX, cY, cXNom, cYNom ;
		
	w = Math.round(C_MWIDTH 	* (1 + s)) ;
	h = Math.round(C_MHEIGHT 	* (1 + s)) ;
		
    // Compute original (non-scaled) center point, AKA 'nominal' center point
    cXNom = C_MWIDTH / 2 ;
    cYNom = C_MHEIGHT / 2 ;
    
    // Compute current center point (with scaling factor applied)
    cX	= w / 2 ;
    cY	= h / 2 ;
    
    // Adjust width and height
    M.style.display = 'none' ;
    M.style.width   = w + 'px' ;
    M.style.height  = h + 'px' ;
    
    // NOW ... Adjust positioning to keep the mandala centered
    M.style.left	= -1 * Math.round(cX - cXNom) + 'px' ;
    M.style.top		= -1 * Math.round(cY - cYNom) + 'px' ;
    M.style.display = 'block' ; // will this flicker?
}

// #SEC_JSMAIN
function spawnBubble()
{
	//console.log('spawnBubble called ...' + _BUBREG.length) ;
	
	// If we've already spawned max number of bubbles, skip this...
	if(_BUBREG.length > C_BUB_MAX){ console.log('Max bubbles exceeded ...') ; return ;}
	
	// Generate random test value (random, between 0 and 1.0)
	// If it falls outside the probability factor, do nothing. Return.
	var p = C_BUB_SPAWNPROB ;
	var t = Math.random() ;
	//console.log('T value: '+t+', P value: '+p) ;
	
	if(t > p) return ;
	
	// If we fall through to here, time to spawn a bubble ...
	var cnvDom ;
	
	var r = randomInt(C_BUB_RADIUS_MIN, C_BUB_RADIUS_MAX) ;
	var l = randomInt(C_BUB_LSPAN_MIN, C_BUB_LSPAN_MAX) ;
	//var o = randomInt(C_BUB_OPAC_MIN * 100, C_BUB_OPAC_MAX * 100) / 100 ;
	var o = C_BUB_OPAC[_bgIdx] ;

	// Position bubble so its edges always remain within padding
	var x = randomInt(C_BUB_EDGEPAD + 2 * r, _SCRWID - C_BUB_EDGEPAD - 2 * r) ;
	var y = randomInt(C_BUB_EDGEPAD + 2 * r, _SCRHGT - C_BUB_EDGEPAD - 2 * r) ;

	// Start out perfectly round (CSS transform: scale(1,1))
	var ws = 1 ;
	var hs = 1 ;
	
	var dx = randomInt(C_BUBDX_MIN,C_BUBDX_MAX) ;
	var dy = randomInt(C_BUBDY_MIN,C_BUBDY_MAX) ;

	var dws = randomInt(C_BUBDWS_MIN,C_BUBDWS_MAX) / 1000 ;
	var dhs = randomInt(C_BUBDHS_MIN,C_BUBDHS_MAX) / 1000 ;

	// Look up valid geometries for colour we're on, randomly select one
	var geom = C_BUB_GEOM[_bgIdx] ;
	var sides = geom[randomInt(0,geom.length - 1)] ;
	
	//console.log('Spawning bubble with r, o, l, x, y: '+r+', '+o+', '+l+', '+x+', '+y) ;
	
	// Create canvas, draw on it
	cnvDom = drawBubbleCnv(r,sides);
	
	// TODO: see about blanket listener on parent element, would it decrease latency?
	// Attach event handler on <canvas> object
	cnvDom.addEventListener(C_TAPEVENT, bubClick, false);
	
	// Position canvas and set opacity to zero (in preparation for fade in)
	cnvDom.style.left 		= x + 'px' ;
	cnvDom.style.top 		= y + 'px' ;
	cnvDom.style.opacity 	= 0	;
	
	// Tap/Click handler needs to lookup which bubble was hit
	// Assign it a serial number, stored in the <canvas> id property
	cnvDom.id = _BUB_TOTAL ;
	
	// Add to bubble registry, increment total bubble count
	_BUBREG.push({	'ser':_BUB_TOTAL,
					'cnv':cnvDom,
					'lspan':l,
					'o':o,'r':r,'x':x,'y':y,'ws':ws,'hs':hs,
					'dx':dx,'dy':dy,
					'dws':dws,'dhs':dhs}) ;
	
	_BUB_TOTAL++ ;

	// Finally ... append into parent container and start fade ...
 	document.getElementById('bubble-container').appendChild(cnvDom) ;
 	fadeElementIn(cnvDom,C_BUB_FADEIN,function(){},o) ;
}

// Called on an interval 1/4~ish of bubble's lifespan
// changes direction, height/width scaling
// applies to random bubbles in bubble registry
function updateBubDyn()
{
	console.log('UBD called...') ;
	var p = 0.2 ;
	var t ;

	for(var i = 0; i < _BUBREG.length; i++)
	{
		t = Math.random() ;
		if(t > p) continue ;

		_BUBREG[i].dx = randomInt(C_BUBDX_MIN,C_BUBDX_MAX) ;
		_BUBREG[i].dy = randomInt(C_BUBDY_MIN,C_BUBDY_MAX) ;

		_BUBREG[i].dws = randomInt(C_BUBDWS_MIN,C_BUBDWS_MAX) / 1000 ;
		_BUBREG[i].dhs = randomInt(C_BUBDHS_MIN,C_BUBDHS_MAX) / 1000 ;
	}
}

function doHit()
{
	_BUB_CHIT++ ;
	_BUB_CMISS = 0 ;

	updateLFDisplay() ;

	if(_BUB_CHIT == C_HIT_CONSEC)
	{
		// Gain a life! Reset consec. counter
		_LF++ ;
		_BUB_CHIT = 0 ;
		updateLFDisplay() ;
		
		alert('+1 life!') ;
		updateLFDisplay() ;
	}
}

function doMiss()
{
	_BUB_CMISS++ ;
	_BUB_CHIT = 0 ;

	updateLFDisplay() ;
	
	// 5 consecutive misses, you're done!
	if(_BUB_CMISS == C_HIT_CONSEC)
	{
		_LF-- ;

		updateLFDisplay() ;

		if(_LF == 0) gameOver() ;

		_BUB_CMISS = 0 ;

		updateLFDisplay() ;
	}	
}

function updateLFDisplay()
{
	var str = 'H: ' + _BUB_CHIT + ' | M: ' + _BUB_CMISS + ' | L: ' + _LF ;
	document.getElementById('lf').innerHTML = str ;
}

var _IFIRE ;
var _FIRECOUNT = 0 ;
var _RMOPAC = 0 ;
function deathSequence()
{
	// Halt tween ticker, bubble spawner, audio looper, and hit/miss queue
	window.clearInterval(_ITWN) ;
	window.clearInterval(_IBSP) ;
	window.clearInterval(_ILPP) ;
	window.clearInterval(_IHMQ) ;
	window.clearInterval(_IUBR) ;

	// Make bloody red matte 'visible' (although its opacity is zero here...)
	document.getElementById('red-matte').style.display = 'block' ;
	//document.getElementById('red-matte').style.opacity = 0 ;

	// Fire 5 bullets at ~1s intervals
	_IFIRE = window.setInterval('fireBullet()',1200) ;
}

// Fires a bullet, adds a bullet hole
function fireBullet()
{
	// Continue processing shard reg ...
	if(_SHARDREG.length) return 0 ;

	if(_FIRECOUNT >= 5)
	{
		window.clearInterval(_IFIRE) ;
		gameOver() ;
		return 0 ;
	}

	playSfx(2) ;

	var el = document.createElement('div') ;

	el.style.position = 'absolute' ;

	el.style.width = '300px' ;
	el.style.height = '300px' ;

	el.style.border = '0px' ;

	/*
	el.style.backgroundPosition = 'center' ;
	el.style.backgroundAttachment = 'fixed' ;
	el.style.backgroundRepeat = 'no-repeat' ;
	el.style.backgroundImage = "url('img/bullet-hole-" + randomInt(1,4) + ".png')";
	*/

	el.style.background = "url('img/bullet-hole-" + randomInt(1,4) + ".png') no-repeat";
	//el.style.backgroundPosition = 'center' ;
	//el.style.backgroundAttachment = 'fixed' ;

	el.style.zIndex = 15500 ;
	el.style.left = randomInt(50,800) + 'px' ;
	el.style.top = randomInt(50,500) + 'px' ;
	el.style.webkitTransform = 'rotate(' + randomInt(0,360) + 'deg)' ;

	document.getElementById('thebody').appendChild(el) ;

	_RMOPAC += 15 ;
	document.getElementById('red-matte').style.opacity = _RMOPAC/100 ;

	_FIRECOUNT++ ;
}

function gameOver()
{
	alert('game over!') ;
	window.setTimeout(function(){window.location.href = "index.html" ;},5000) ;
}


function updateBubReg()
{
	for(var i = 0; i < _BUBREG.length; i++)
	{
		if(_BUBREG[i].lspan <= 0)
		{
			popBub(i) ;
			// Trigger a miss
			_HMQ.push('M') ;
			continue ;
		}
		
		// Update bubble's position
		_BUBREG[i].x = _BUBREG[i].x + _BUBREG[i].dx ;
		_BUBREG[i].y = _BUBREG[i].y + _BUBREG[i].dy ;

		// Update bubble's width/height scale
		_BUBREG[i].ws = _BUBREG[i].ws + _BUBREG[i].dws ;
		_BUBREG[i].hs = _BUBREG[i].hs + _BUBREG[i].dhs ;

		// Apply transformation
		_BUBREG[i].cnv.style.left 		= _BUBREG[i].x + 'px' ;
		_BUBREG[i].cnv.style.top 		= _BUBREG[i].y + 'px' ;
		
		//_BUBREG[i].cnv.style.webkitTransform = 'scale(' + _BUBREG[i].ws + ',' + _BUBREG[i].hs + ')' ; 

		//_BUBREG[i].cnv.style.width 		= _BUBREG[i].w + 'px' ;
		//_BUBREG[i].cnv.style.height 	= _BUBREG[i].h + 'px' ;
		
		// Decrement lifecycle counter
		_BUBREG[i].lspan = _BUBREG[i].lspan - C_UBR_INT ;
	}
}

// x,y coordinates for center of explosion
function popBub(i)
{	
	var cnv ;

	//var x,y ;

	var burstX = _BUBREG[i].x + _BUBREG[i].r ;
	var burstY = _BUBREG[i].y + _BUBREG[i].r ;

	// TODO: make these constants ...
	burstX -= randomInt(0,5) ;
	burstY -= randomInt(0,5) ;

	// Scaling factor (px) applied just before disappearing
	var wFac, hFac ;
	
	//x = _BUBREG[i].x + _BUBREG[i].r ;
	//y = _BUBREG[i].y + _BUBREG[i].r ;
	
	// Calculate 'pre-burst expansion' values (size expands by this many pixels)
	wFac = Math.floor(2 * _BUBREG[i].r * C_BUB_PBEXP) ;
	hFac = Math.floor(2 * _BUBREG[i].r * C_BUB_PBEXP) ;

	// Trigger burst sound effect
	playSfx(0) ;

	// center (x,y), blast radius 'r', particle count 'p'
	// TODO: transfer blast radius scaling factor into constant
	//explode(burstX, burstY, Math.floor(_BUBREG[i].r * 2), randomInt(3,5)) ;
	// TODO: transfer '2' into a constant (multiplier on radius to get shard radius)
	spawnShardCanvas(burstX, burstY, Math.floor(_BUBREG[i].r * 2), randomInt(3,5)) ;

	// Does this get handled by GC?
	//_BUBREG[i].cnv.parentNode.removeChild(_BUBREG[i].cnv) ;
	//_BUBREG.splice(i,1) ;
	
	cnv = _BUBREG[i].cnv ;

	cnv.style.opacity 	= C_BUB_PBOPAC ;
	cnv.style.width 	= 2 * _BUBREG[i].r + wFac + 'px' ;
	cnv.style.height 	= 2 * _BUBREG[i].r + hFac + 'px' ;

	// Offset left and top coords to keep bubble centered
	cnv.style.left		= _BUBREG[i].x - Math.floor(wFac / 2) + 'px' ;
	cnv.style.top		= _BUBREG[i].y - Math.floor(hFac / 2) + 'px' ;
	
	// Remove from _BUBREG immediately, but leave canvas element briefly visible ...
	_BUBREG.splice(i,1) ;

	// TODO: transfer pre-burst expansion time into constant
	window.setTimeout(function(){ cnv.parentNode.removeChild(cnv) },120) ;
}

// Ends the game
function halt()
{
  // TODO: wait until last bubble pops (or is popped)
  // before displaying final results ...
  
  var score = Math.round((_BUB_HIT / _BUB_TOTAL) * 100) ;
  var str = 'Finished!'+"\n"
  str += 'Bubbles Spawned: '+_BUB_TOTAL+"\n" ;
  str += 'Bubbles Hit: '+_BUB_HIT+"\n" ;
  str += 'Your Score: '+score+'%' ;
  
  //alert(str) ;
  endSequence1() ;
}

// Triggers an explosion at center point cx,cy (screen coordinates)
// With average blast radius 'rNom' and particle count 'p'
// updateShardReg() takes care of animating and rendering the particles
function spawnShardCanvas(cx, cy, rNom, p)
{
	var srTmp = [] ; // complete entry for _SHARDREG
	var shTmp = [] ; // individual entries for shards (contained in each srTmp entry)

	var elCnv ;
	var elCtx ;

	var aNom ;
	var a ;			// Angle of each shard, as its being calculated (including 'organic factor' )

	elCnv = document.createElement('canvas') ;

	elCnv.width 			= 2 * ( rNom + C_SHARDPAD ) ;
	elCnv.height 			= 2 * ( rNom + C_SHARDPAD ) ;

	elCnv.style.position 	= 'absolute' ;

	elCnv.style.left 		= ( cx - rNom - C_SHARDPAD ) + 'px' ;
	elCnv.style.top 		= ( cy - rNom - C_SHARDPAD ) + 'px' ;
	elCnv.style.zIndex		= 200 ;

	elCtx = elCnv.getContext('2d') ;

	srTmp.push(elCnv) ;
	srTmp.push(elCtx) ;
	srTmp.push(0) ; // 't' value, initialize to zero ... runs up to 100, indicating 100% complete animation

	srTmp.push(cx) ;
	srTmp.push(cy) ;

	
	// Now calculate starting positions and trajectories of particles
	for(var i = 0; i < p; i++)
	{
		shTmp = [] ;

		aNom = (( 2 * Math.PI ) / p) * i ;
		
		// Apply +/- percentage according to organic factors
		a = aNom * ( randomInt((100 - C_SDIST_ORG),(100 + C_SDIST_ORG)) / 100 ) ;
		r = rNom * ( randomInt((100 - C_SDIST_ORG),(100 + C_BLSTRAD_ORG)) / 100 ) ;

		shTmp.push(a) ;
		shTmp.push(Math.round(r)) ;
		
		srTmp.push(shTmp) ;
	}
	
	_SHARDREG.push(srTmp) ;
	_elSc.appendChild(srTmp[0]) ;
}

function updateShardReg()
{
	if(!_SHARDREG.length) return 0 ;

	var srEnt ;
	var cnv ;
	var ctx ;
	var rCur ;
	var x,y ; // xy position of particle being redrawn (calculated from rCur, a, and cnv center)
	var t ;
	var r ;

	// Hide shards
	_elSc.style.display = 'none' ;

	// Redraw canvases
	for(var i = 0; i < _SHARDREG.length; i++)
	{
		// Loop up from array only once ...
		// Should get stored as reference to array element
		srEnt = _SHARDREG[i] ;
		cnv = srEnt[0] ;
		ctx = srEnt[1] ;

		// Clear canvas for redrawing
		//ctx.clearRect(0,0,cnv.width,cnv.height) ;
		cnv.width = cnv.width ;

		srEnt[2] = srEnt[2] + C_SVELOC ;
		t = srEnt[2] ;

		// All entries from index 5 onwards are the individual shards
		for(var j = 5; j < srEnt.length; j++)
		{
			// t (scaled to 0-1.0) * r * cos(a) ... / ... sin(a)
			x = Math.round(srEnt[0].width / 2) + ((t / 100) * srEnt[j][1] * Math.cos(srEnt[j][0])) ;
			
			// width/height are same
			y = Math.round(srEnt[0].width / 2 ) + ((t / 100) * srEnt[j][1] * Math.sin(srEnt[j][0])) ;
			
			x = Math.round(x) ;
			y = Math.round(y) ;

			// Redraw shard, with a random number of edges
			// ... morphs as it blasts outwards
			drawShard(ctx, x, y, randomInt(3,8)) ;
		}
	}

	window.setTimeout(function(){_elSc.style.display = 'block'}, 100) ;
	//elSc.style.display = 'block' ;
}

function shardRegGC()
{
	var srEnt ;
	var cnv ;

	for(var i = 0; i < _SHARDREG.length; i++)
	{
		srEnt = _SHARDREG[i] ;

		cnv = srEnt[0] ;
		
		// If t has reached 100 (or passed it), remove canvas .. and _SHARDREG entry
		if(srEnt[2] >= 100)
		{
			_SHARDREG.splice(i,1) ;
			cnv.parentNode.removeChild(cnv) ;
			continue ;
		}
	}
}


/*************************************************

   DRAWING FUNCTIONS (BUBBLES, DIGITS)

**************************************************/

// Creates a bubble <canvas>, draws a bubble on it,
// returns <canvas> DOM ref
// <canvas> is rendered at 2x native size for a slightly pixellated effect
// 'r' refers to the radius of the SCALED bubble... SO.. we need to draw
// it at 'half size' so it'll be correct when scaled up
// 'e' is the edge count. A polygon with this many edges is drawn.
// the value 99 means 'draw a circle'
function drawBubbleCnv(r, e)
{	
	var cnv = document.createElement('canvas') ;
	
	// Draw bubble at half size and scale it up
	// So it's a bit fuzzy like the SG mandalas ...
	var rScaled = Math.round(r/2) ;
	
	cnv.width 					= 2 * rScaled ;
	cnv.height 					= 2 * rScaled ;
	cnv.style.position 	= 'absolute' ;
	cnv.style.width 		= 2 * r + 'px' ;
	cnv.style.height 		= 2 * r + 'px' ;
	cnv.style.opacity 	= 0 ; // starts at zero, will be faded in
	cnv.style.zIndex 		= 200 ;
	
	var ctx = cnv.getContext('2d') ;

	if(e == 99) drawCell(ctx, rScaled, rScaled, rScaled) ;
	else drawPoly(ctx, rScaled, rScaled, rScaled, e) ;

	return cnv ;
}

// s = side count (for polygon)
function drawShard(ctx, x,y,s)
{
	var pts = getPolyPts(x, y, 6, s, 0) ; // leave r and aOffset fixed, for now
	var x,y ;

	x = pts[0][0] ;
	y = pts[0][1] ;

	ctx.moveTo(x,y) ;

	for(var i = 1; i < pts.length; i++)
	{
		x = pts[i][0] ;
		y = pts[i][1] ;

		ctx.lineTo(x, y) ;
	}

	ctx.closePath() ;

	ctx.fillStyle = '#FFF' ;
	ctx.fill() ;
	//ctx.strokeStyle = '#fff' ;
	//ctx.stroke() ;
}

// Renders a numeric value into a grouping of digit <img>'s
// iDig tracks which decimal place we're rendering (0=1's, 1=10's, 2=100's)
function renderDigits(idPrefix,valInt)
{
	var dig ; // current digit being evaluated
	var valStr = valInt.toString() ;
	var el ; // current element of digit being rendered
	
	for(var i = 0 ; i < valStr.length; i++)
	{
		dig = valStr.substr(i,1) ;
		
		el = document.getElementById(idPrefix+'-'+i) ;
		el.src = 'img/dig-'+dig+'.gif' ;
		el.style.display = 'block' ;
	}
}

// Used only for rendering the final score percentage ...
function renderDigitsRight(idPrefix,valInt)
{
	var iDig = 0 ;
	var dig ; // current digit being evaluated
	var valStr = valInt.toString() ;
	var el ; // current element of digit being rendered
	
	for(var i = valStr.length - 1 ; i >= 0; i--)
	{
		dig = valStr.substr(i,1) ;
		
		el = document.getElementById(idPrefix+'-'+iDig) ;
		el.src = 'img/dig-'+dig+'.gif' ;
		el.style.display = 'block' ;
		
		iDig++ ;
	}
}

function bubClick(e)
{	
	var ser = e.target.id ;
		
	// Find index in _BUBREG of bubble with serial #  'ser'
	for(var i = 0; i < _BUBREG.length; i++)
	{
		if(_BUBREG[i].ser == ser) break ;
	}
	
	popBub(i) ;
	
	// Trigger a hit
	_HMQ.push('H') ;

	// Register hit (for total score at end)
	_BUB_HIT++ ;
}

function nextBg()
{
	// If we're on the last background already, we're done ... halt the game
	if(_bgIdx == 6)
	{
		halt() ;
		return ;
	}
	
	// Retrieve background element and make it disappear!
	var el = document.getElementById('bg-'+_bgIdx) ;
		
    fadeElementOut(el, 4600, function () {
        // Remove from DOM tree once invisible ...
        el.parentElement.removeChild(el) ;
    });
    
    _bgIdx++ ;
}


/*************************************************

   UTILITY / HELPER FUNCTIONS [#SEC_JSUTIL]

**************************************************/

function randomInt(min, max)
{
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function degToRad(d)
{
	return (d / 360) * 2 * Math.PI ;
}

function tweenTicker()
{
    if(_PAUSESG) return ;
    TWEEN.update() ;
}

function fadeElementIn(el,dur,fnComplete,opacFinal)
{
    var opacTween = { opac: 0.0 } ;
    if(!opacFinal) opacFinal = 1.0 ;
    var eas = TWEEN.Easing.Quadratic.InOut ;

    new TWEEN.Tween( opacTween )
        .to( { opac:opacFinal }, dur )
        .easing( eas )
        .onComplete(fnComplete)
        .onUpdate( function () {
            el.style.opacity = opacTween.opac ;
        }).start();
}

function fadeElementOut(el,dur,fnComplete,opacInit)
{
		if(!opacInit) opacInit = 1.0 ;
		var opacTween = { opac: opacInit };
		
    var eas = TWEEN.Easing.Quadratic.InOut ;

    new TWEEN.Tween( opacTween )
        .to( { opac:0 }, dur )
        .easing( eas )
        .onComplete(fnComplete)
        .onUpdate( function () {
            el.style.opacity = opacTween.opac ;
        }).start();
}

function drawPoly(ctx, cX, cY, r, edgeCount, aOffset)
{
	if(!aOffset) aOffset = 0 ;

	var pts = getPolyPts(cX, cY, r, edgeCount, aOffset) ;
	var cRad = Math.floor(C_BUB_CRAT * r) ;
	doPolyDraw(ctx, pts, cRad,0.6) ;

	pts = getPolyPts(cX, cY, r - 1, edgeCount, aOffset) ;

	doPolyDraw(ctx, pts, cRad,0.4) ;

	pts = getPolyPts(cX, cY, r - 2, edgeCount, aOffset) ;

	doPolyDraw(ctx, pts, cRad,0.3) ;
	pts = getPolyPts(cX, cY, r - 3, edgeCount, aOffset) ;

	doPolyDraw(ctx, pts, cRad,0.2) ;
}

function getPolyPts(cX, cY, r, edgeCount, aOffset)
{
	if(!aOffset) aOffset = 0 ;
	
	var a = 0 ;
	var x = 0 ;
	var y = 0 ;

	var pts = [] ;

	for(var i = 0; i < edgeCount; i++)
	{
		a = aOffset + 2 * Math.PI / edgeCount * i ;
		x = cX + r * Math.cos(a) ;
		y = cY + r * Math.sin(a) ;

		pts.push([Math.round(x),Math.round(y)]) ;
	}

	return pts ;
}

// Lifted from http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
function doPolyDraw(ctx, pts, radius, opac) {
  if (radius > 0) pts = getRoundedPoints(pts, radius);

  var i, pt, len = pts.length;
  ctx.beginPath();
  for (i = 0; i < len; i++) {
    pt = pts[i];
    if (i == 0) {          
      ctx.moveTo(pt[0], pt[1]);
    } else {
      ctx.lineTo(pt[0], pt[1]);
    }
    if (radius > 0) {
      ctx.quadraticCurveTo(pt[2], pt[3], pt[4], pt[5]);
    }
  }
  ctx.closePath();
  ctx.strokeStyle = 'rgba(255,255,255,'+opac+')' ;
  ctx.stroke() ;
}

function getRoundedPoints(pts, radius) {
  var i1, i2, i3, p1, p2, p3, prevPt, nextPt,
      len = pts.length,
      res = new Array(len);
  for (i2 = 0; i2 < len; i2++) {
    i1 = i2-1;
    i3 = i2+1;
    if (i1 < 0) {
      i1 = len - 1;
    }
    if (i3 == len) {
      i3 = 0;
    }
    p1 = pts[i1];
    p2 = pts[i2];
    p3 = pts[i3];
    prevPt = getRoundedPoint(p1[0], p1[1], p2[0], p2[1], radius, false);
    nextPt = getRoundedPoint(p2[0], p2[1], p3[0], p3[1], radius, true);
    res[i2] = [prevPt[0], prevPt[1], p2[0], p2[1], nextPt[0], nextPt[1]];
  }
  return res;
};

function getRoundedPoint(x1, y1, x2, y2, radius, first) {
  var total = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)),
      idx = first ? radius / total : (total - radius) / total;
  return [x1 + (idx * (x2 - x1)), y1 + (idx * (y2 - y1))];
};

/*************************************************

   TITLE, LAUNCH, END,ETC. SEQUENCES [#SEC_JSSEQ]

**************************************************/
function titleSequence1()
{
	//window.location.href = 'xplosion-canvas.html' ;
	//return ;
	
	_ITWN = window.setInterval('tweenTicker()',C_TTICK_INT) ;
	window.setTimeout('titleSequence2()',2000) ;
}

function titleSequence2()
{
	var el = document.getElementById('thebody') ;

	fadeElementOut(document.getElementById('title-bg-black'),2000,function(){
		// Once fadeout is done, make 'tap to start' region active
		// and start flashing 'tap to start' lettering
		_ITTS = window.setInterval('ttsToggle()',1000) ;
		el.addEventListener(C_TAPEVENT,launchSequence1,false) ;
	}) ;
}

// Called on an interval, toggles 'tap to start' on and off
function ttsToggle()
{
	var el = document.getElementById('title-lettr-tapstart') ;
	if(el.style.display == 'block') el.style.display = 'none' ;
	else el.style.display = 'block' ;
}

function launchSequence1()
{
	// Quit flashing 'tap to start...', it's gone
	window.clearInterval(_ITTS) ;
	
	// Cancel event listener for 'tap to start'
	document.getElementById('thebody').removeEventListener(C_TAPEVENT,launchSequence1,false) ;
	
	// Hide that shit
	document.getElementById('title-lettr-tapstart').style.display = 'none' ;
	document.getElementById('title-lettr-title').style.display = 'none' ;
	
	// Preload SFX here so they're ready once looping starts
	_AUDIO 	= document.getElementById('snd-sprite') ;

	// Start the loop here too, because it'll sound sexy ...
	// And audio needs to be triggered by a user event
	// Because of some bullshit data plan babysitting routine :p
	playAudio() ;
	_AUD_TIMEOUT = window.setTimeout('pauseAudio()',2200) ; // Stop after 2.2s

	_ILPP = window.setInterval('doAudioLoop()',4000) ;

	// Fade in start dialog
	var elDlog 	= document.getElementById('dlog-start') ; 
	
	fadeElementIn(elDlog,1000,function(){
			window.setTimeout(launchSequence2,1000)
		}) ;
}

function launchSequence2()
{
	fadeElementIn(document.getElementById('lettr-ready'),1000,function(){
			window.setTimeout('launchSequence3()',750) ;
		}) ;
}

// Begin countdown

function launchSequence3()
{
	var elCdDig = document.getElementById('countdown-digit') ;
	
	// Digit is already set to '5' through HTML markup
	elCdDig.style.display = 'block' ;
	
	// after 1/3 second, initiate the dot sequence ...
	window.setTimeout('launchSequence4()',333) ;
}

var cdDig = 3 ; // current countdown digit
var iDot 	= 1 ; // counts number of dots displayed
function launchSequence4()
{
	if(iDot > 3 && cdDig == 1)
	{
		launchSequence5() ;
		return ;
	}
	
	if(iDot > 3)
	{
		document.getElementById('countdown-dot-1').style.display = 'none' ;
		document.getElementById('countdown-dot-2').style.display = 'none' ;
		document.getElementById('countdown-dot-3').style.display = 'none' ;
		
		iDot = 1 ;
		cdDig-- ;
		
		// Decrement coundown digit
		document.getElementById('countdown-digit').src = 'img/dig-'+cdDig+'.gif' ;
		
		// Wait another 1/3 second, call launchSequence4 again ...
		window.setTimeout('launchSequence4()',333) ;
		return ;
	}
	
	document.getElementById('countdown-dot-'+iDot).style.display = 'block' ;
	
	iDot++ ;
	
	// After 1/3 second, show the next dot...
	window.setTimeout('launchSequence4()',333) ;
}

function launchSequence5()
{
	fadeElementOut(document.getElementById('dlog-start'),1000,launchSequence6) ;
}

// Final step ... draw the canvases, set the tickers... and pull the curtain
function launchSequence6()
{
    // Grab reference to shard-container element
    _elSc = document.getElementById('shard-container') ;

    // Fire up tickers needed for game ...
    _ISWC = window.setInterval('nextBg()',60000) ;
    _IBSP = window.setInterval('spawnBubble()',C_SBB_INT) ;
	_IUBR = window.setInterval('updateBubReg()',C_UBR_INT) ;
	//_IUBD = window.setInterval('updateBubDyn()',C_UBD_INT) ;
	_IUSR = window.setInterval('updateShardReg()',C_USR_INT) ;
	_ISGC = window.setInterval('shardRegGC()',C_SGC_INT) ;
	_IHMQ = window.setInterval('processHMQ()',C_HMQ_INT) ;

	// Start SG generator
	initSgGen() ;

	// Pull the curtain
	fadeElementOut(document.getElementById('title-bg-mandala'),1500,function(){}) ;
}

function bnHide(e)
{
	document.getElementById('build-number').style.display = 'none' ;
}

// Called when game ends
function endSequence1()
{
	var score = Math.round((_BUB_HIT / _BUB_TOTAL) * 100) ;
	
	// First step, render _BUBTOTAL, _BUBHIT and score ...
  	renderDigits('total-dig',_BUB_TOTAL) ;
	renderDigits('popped-dig',_BUB_HIT) ;
	renderDigitsRight('score-dig',score) ;
		
	fadeElementIn(document.getElementById('dlog-end'),1000,endSequence2) ;
}

// Show 'total' label
function endSequence2()
{
	document.getElementById('lettr-total').style.display = 'block' ;
	window.setTimeout('endSequence3()',500) ;
}

// Reveal 'total' label dots
function endSequence3()
{
	var elTotal = document.getElementById('lettr-total')
	var tween = { width: 94 } ;
  	new TWEEN.Tween( tween )
      .to( { width:360 }, 1200 )
      .easing( TWEEN.Easing.Linear.None )
      .onComplete(function(){window.setTimeout('endSequence4()',500)})
      .onUpdate( function () {
          elTotal.style.width = tween.width+'px' ;
      }).start();
}

// Show 'total' value
function endSequence4()
{
	document.getElementById('total-dig-0').style.opacity = 1 ;
	document.getElementById('total-dig-1').style.opacity = 1 ;
	document.getElementById('total-dig-2').style.opacity = 1 ;
	
	window.setTimeout('endSequence5()',1000) ;
}

// Reveal 'popped' label
function endSequence5()
{
	document.getElementById('lettr-popped').style.display = 'block' ;
	window.setTimeout('endSequence6()',500) ;
}

// Reveal 'popped' label dots
function endSequence6()
{
	var elPopped = document.getElementById('lettr-popped') ;
	var tween = { width: 94 } ;
  	new TWEEN.Tween( tween )
      .to( { width:360 }, 1200 )
      .easing( TWEEN.Easing.Linear.None )
      .onComplete(function(){window.setTimeout('endSequence7()',500)})
      .onUpdate( function () {
          elPopped.style.width = tween.width+'px' ;
      }).start();
}

// Show 'popped' value
function endSequence7()
{
	document.getElementById('popped-dig-0').style.opacity = 1 ;
	document.getElementById('popped-dig-1').style.opacity = 1 ;
	document.getElementById('popped-dig-2').style.opacity = 1 ;
	
	window.setTimeout('endSequence8()',1200) ;
}

// Show final score
function endSequence8()
{
	document.getElementById('lettr-score').style.display = 'block' ;
	document.getElementById('score-dig-0').style.opacity = 1 ;
	document.getElementById('score-dig-1').style.opacity = 1 ;
	document.getElementById('score-dig-2').style.opacity = 1 ;
}

</script>
</body>
</html>